{
    "docs": [
        {
            "location": "/", 
            "text": "Wallace\n\n\nWallace is a platform for conducting research on experimental cultural evolution. Its namesake is Alfred Russel Wallace, a British naturalist and the oft-ignored codiscoverer of evolution by natural selection. You can use Wallace to create new experiments or to reproduce existing experiments.\n\n\nWant to take Wallace for a test drive? Start \nhere\n.\n\n\nFeel like contributing to Wallace? Great! Start \nhere\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#wallace", 
            "text": "Wallace is a platform for conducting research on experimental cultural evolution. Its namesake is Alfred Russel Wallace, a British naturalist and the oft-ignored codiscoverer of evolution by natural selection. You can use Wallace to create new experiments or to reproduce existing experiments.  Want to take Wallace for a test drive? Start  here .  Feel like contributing to Wallace? Great! Start  here .", 
            "title": "Wallace"
        }, 
        {
            "location": "/Installing-Wallace-(for-users)/", 
            "text": "If you would like to contribute to Wallace, please follow these \nalternative install instructions\n.\n\n\nInstall Python\n\n\nWallace is written in the language Python. For it to work, you will need to have Python 2.7 installed. You can check what version of Python you have by running:\n\n\npython --version\n\n\n\n\nIf you do not have Python 2.7 installed, you can install it from the \nPython website\n. \n\n\nInstall Postgres\n\n\nWallace uses Postgres to create local databases. On OS X, install Postgres from \npostgresapp.com\n. This will require downloading a zip file, unzipping the file and installing the unzipped application. \n\n\nYou will then need to add Postgres to your PATH environmental variable. If you use the default location for installing applications on OS X (namely \n/Applications\n), you can adjust your path by running the following command:\n\n\nexport PATH=\n/Applications/Postgres.app/Contents/Versions/9.3/bin:$PATH\n\n\n\n\n\nNB: If you have installed a more recent version of Postgres (e.g., the \nthe upcoming version 9.4\n), you may need to alter that command slightly to accommodate the more recent version number. To double check which version to include, then run:    \n\n\nls /Applications/Postgres.app/Contents/Versions/\n\n\n\n\nWhatever number that returns is the version number that you should place in the \nexport\n command above. If it does not return a number, you have not installed Postgres correctly in your \n/Applications\n folder or something else is horribly wrong.\n\n\nCreate the Database\n\n\nAfter installing Postgres, you will need to create a database for your experiments to use. Run the following command from the comand line:\n\n\npsql -c 'create database wallace;' -U postgres\n\n\n\n\nInstall Wallace\n\n\nInstall Wallace from the terminal by running\n\n\npip install wallace-platform\n\n\n\n\nTest that your installation works by running:\n\n\nwallace --version\n\n\n\n\nNext, you'll need \naccess keys for AWS, Heroku, etc.", 
            "title": "For users"
        }, 
        {
            "location": "/Installing-Wallace-(for-users)/#install-python", 
            "text": "Wallace is written in the language Python. For it to work, you will need to have Python 2.7 installed. You can check what version of Python you have by running:  python --version  If you do not have Python 2.7 installed, you can install it from the  Python website .", 
            "title": "Install Python"
        }, 
        {
            "location": "/Installing-Wallace-(for-users)/#install-postgres", 
            "text": "Wallace uses Postgres to create local databases. On OS X, install Postgres from  postgresapp.com . This will require downloading a zip file, unzipping the file and installing the unzipped application.   You will then need to add Postgres to your PATH environmental variable. If you use the default location for installing applications on OS X (namely  /Applications ), you can adjust your path by running the following command:  export PATH= /Applications/Postgres.app/Contents/Versions/9.3/bin:$PATH   NB: If you have installed a more recent version of Postgres (e.g., the  the upcoming version 9.4 ), you may need to alter that command slightly to accommodate the more recent version number. To double check which version to include, then run:      ls /Applications/Postgres.app/Contents/Versions/  Whatever number that returns is the version number that you should place in the  export  command above. If it does not return a number, you have not installed Postgres correctly in your  /Applications  folder or something else is horribly wrong.", 
            "title": "Install Postgres"
        }, 
        {
            "location": "/Installing-Wallace-(for-users)/#create-the-database", 
            "text": "After installing Postgres, you will need to create a database for your experiments to use. Run the following command from the comand line:  psql -c 'create database wallace;' -U postgres", 
            "title": "Create the Database"
        }, 
        {
            "location": "/Installing-Wallace-(for-users)/#install-wallace", 
            "text": "Install Wallace from the terminal by running  pip install wallace-platform  Test that your installation works by running:  wallace --version  Next, you'll need  access keys for AWS, Heroku, etc.", 
            "title": "Install Wallace"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/", 
            "text": "Developer's installation of Wallace\n\n\nInstall Python 2.7\n\n\nYou will need Python 2.7. You can check what version of Python you have by running:\n    \npython --version\n\nIf you do not have Python 2.7 installed, you can install it from the \nPython website\n.\n\n\nOr, if you use Homebrew:\n\n\nbrew install python\n\n\n\n\nIf you have Python 3.\nx\n installed and and symlinked to the command \npython\n, you will need to create a \nvirtualenv\n that interprets the code as \npython2.7\n (for compatibility with the \npsiturk\n module). Fortunately, we will be creating a virtual environment anyway, so as long as you run \nbrew install python\n and you don't run into any errors because of your symlinks, then you can proceed with the instructions. If you do run into any errors, good luck, we're rooting for you. \n\n\nInstall Postgres\n\n\nOn OS X, we recommend installing \nPostgres.app\n to start and stop the Postgres server.\n\n\nCreate the Database\n\n\nAfter installing Postgres, you will need to create a database for your experiments to use. Run the following command from the comand line:\n\n\npsql -c 'create database wallace;' -U postgres\n\n\n\n\nSet up a virtual environment\n\n\nSet up a virtual environment by running the following commands:\n\n\npip install virtualenv\npip install virtualenvwrapper\nexport WORKON_HOME=$HOME/.virtualenvs\nmkdir -p $WORKON_HOME\nsource $(which virtualenvwrapper.sh)\nmkvirtualenv wallace --python /usr/local/bin/python2.7\n\n\n\n\nThese commands use \npip\n, the Python package manager, to install two packages \nvirtualenv\n and \nvirtualenvwrapper\n. They set up an environmental variable named \nWORKON_HOME\n with a string that gives a path to a subfolder of your home directory (\n~\n) called \nEnvs\n, which the next command (\nmkdir\n) then makes according to the path described in \n$WORKON_HOME\n (recursively, due to the \n-p\n flag). That is where your environments will be stored. The \nsource\n command will run the command that follows, which in this case locates the \nvirtualenvwrapper.sh\n shell script, the contents of which are beyond the scope of this setup tutorial. If you want to know what it does, a more in depth description can be found at \nthis page on \nvirtualenvwrapper.sh\n. Finally, the \nmkvirtualenv\n makes your first virtual environment which you've named \nwallace\n. We have explicitly passed it the location of \npython2.7\n so that even if your \npython\n command has been remapped to \npython3\n, it will create the environment with \npython2.7\n as its interpreter.\n\n\nIn the future, you can work on your virtual environment by running:\n\n\nsource $(which virtualenvwrapper.sh)\nworkon wallace\n\n\n\n\nNB: To stop working on the virtual environment, run \ndeactivate\n. To list all available virtual environments, run \nworkon\n with no arguments.\n\n\nInstall Wallace\n\n\nNext, navigate to the directory where you want to house your development work on Wallace. Once there, clone the Git repository using:\n\n\ngit clone https://github.com/berkeley-cocosci/Wallace\n\n\n\n\nThis will create a directory called \nWallace\n in your current directory. \n\n\nChange into your the new directory and make sure you are still in your virtual environment before installing the dependencies. If you want to be extra carfeul, run the command \nworkon wallace\n, which will ensure that you are in the right virtual environment.\n\n\ncd Wallace\n\n\n\n\nNow we need to install the dependencies using pip:\n\n\npip install -r requirements.txt\n\n\n\n\nNext run \nsetup.py\n with the argument \ndevelop\n:\n\n\npython setup.py develop\n\n\n\n\nTest that your installation works by running:\n\n\nwallace --version\n\n\n\n\nNote\n: if you are using Anaconda and get a long traceback here, please see the special \nAnaconda installation instructions\n.\n\n\nNext, you'll need \naccess keys for AWS, Heroku, etc.", 
            "title": "For developers"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/#developers-installation-of-wallace", 
            "text": "", 
            "title": "Developer's installation of Wallace"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/#install-python-27", 
            "text": "You will need Python 2.7. You can check what version of Python you have by running:\n     python --version \nIf you do not have Python 2.7 installed, you can install it from the  Python website .  Or, if you use Homebrew:  brew install python  If you have Python 3. x  installed and and symlinked to the command  python , you will need to create a  virtualenv  that interprets the code as  python2.7  (for compatibility with the  psiturk  module). Fortunately, we will be creating a virtual environment anyway, so as long as you run  brew install python  and you don't run into any errors because of your symlinks, then you can proceed with the instructions. If you do run into any errors, good luck, we're rooting for you.", 
            "title": "Install Python 2.7"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/#install-postgres", 
            "text": "On OS X, we recommend installing  Postgres.app  to start and stop the Postgres server.", 
            "title": "Install Postgres"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/#create-the-database", 
            "text": "After installing Postgres, you will need to create a database for your experiments to use. Run the following command from the comand line:  psql -c 'create database wallace;' -U postgres", 
            "title": "Create the Database"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/#set-up-a-virtual-environment", 
            "text": "Set up a virtual environment by running the following commands:  pip install virtualenv\npip install virtualenvwrapper\nexport WORKON_HOME=$HOME/.virtualenvs\nmkdir -p $WORKON_HOME\nsource $(which virtualenvwrapper.sh)\nmkvirtualenv wallace --python /usr/local/bin/python2.7  These commands use  pip , the Python package manager, to install two packages  virtualenv  and  virtualenvwrapper . They set up an environmental variable named  WORKON_HOME  with a string that gives a path to a subfolder of your home directory ( ~ ) called  Envs , which the next command ( mkdir ) then makes according to the path described in  $WORKON_HOME  (recursively, due to the  -p  flag). That is where your environments will be stored. The  source  command will run the command that follows, which in this case locates the  virtualenvwrapper.sh  shell script, the contents of which are beyond the scope of this setup tutorial. If you want to know what it does, a more in depth description can be found at  this page on  virtualenvwrapper.sh . Finally, the  mkvirtualenv  makes your first virtual environment which you've named  wallace . We have explicitly passed it the location of  python2.7  so that even if your  python  command has been remapped to  python3 , it will create the environment with  python2.7  as its interpreter.  In the future, you can work on your virtual environment by running:  source $(which virtualenvwrapper.sh)\nworkon wallace  NB: To stop working on the virtual environment, run  deactivate . To list all available virtual environments, run  workon  with no arguments.", 
            "title": "Set up a virtual environment"
        }, 
        {
            "location": "/Developing-Wallace-(setup-guide)/#install-wallace", 
            "text": "Next, navigate to the directory where you want to house your development work on Wallace. Once there, clone the Git repository using:  git clone https://github.com/berkeley-cocosci/Wallace  This will create a directory called  Wallace  in your current directory.   Change into your the new directory and make sure you are still in your virtual environment before installing the dependencies. If you want to be extra carfeul, run the command  workon wallace , which will ensure that you are in the right virtual environment.  cd Wallace  Now we need to install the dependencies using pip:  pip install -r requirements.txt  Next run  setup.py  with the argument  develop :  python setup.py develop  Test that your installation works by running:  wallace --version  Note : if you are using Anaconda and get a long traceback here, please see the special  Anaconda installation instructions .  Next, you'll need  access keys for AWS, Heroku, etc.", 
            "title": "Install Wallace"
        }, 
        {
            "location": "/AWS-etc-keys/", 
            "text": "Before you can use Wallace, you will need accounts with Amazon Web Services, Amazon Mechanical Turk, Heroku, and psiTurk. You will then need to create a configuration file and set up your environment so that Wallace can access your accounts.\n\n\nCreate the configuration file\n\n\nThe first step is to create the Wallace configuration file in your home directory. You can do this using the Wallace command-line utility through\n\n\nwallace setup\n\n\n\nwhich will prepopulate a hidden file \n.wallaceconfig\n in your home directory. Alternatively, you can create this file yourself and fill it in like so:\n\n\n[AWS Access]\naws_access_key_id = ???\naws_secret_access_key = ???\naws_region = us-east-1\n\n[psiTurk Access]\npsiturk_access_key_id = ???\npsiturk_secret_access_id = ???\n\n[Heroku Access]\nheroku_email_address = ???\nheroku_password = ???\n\n[Email Access]\nwallace_email_address = ???\nwallace_email_password = ???\n\n[Task Parameters]\nexperiment_code_version = 1.0\nnum_conds = 1\nnum_counters = 1\n\n[Server Parameters]\nport = 5000\ncutoff_time = 30\nlogfile = -\nloglevel = 0\ndebug = true\nlogin_username = examplename\nlogin_pw = examplepassword\nthreads = 1\nclock_on = true\n\n\n\n\nIn the next steps, we'll fill in your config file with keys.\n\n\nAmazon Web Services API Keys\n\n\nYou can get API keys for Amazon Web Services by \nfollowing these instructions\n. \n\n\nThen fill in the following lines of \n.wallaceconfig\n, replacing \n???\n with your keys:\n\n\n[AWS Access]\naws_access_key_id = ???\naws_secret_access_key = ???\n\n\n\n\nN.B.\n One feature of AWS API keys is that they are only displayed once, and though they can be regenerated, doing so will render invalid previously generated keys. If you are running experiments using a laboratory account (or any other kind of group-owned account), regenerating keys will stop other users who have previously generated keys from being able to use the AWS account. Unless you are sure that you will not be interrupting others' workflows, it is advised that you do \nnot\n generate new API keys. If you are not the primary user of the account, see if you can obtain these keys from others who have successfully used AWS.\n\n\nAmazon Mechanical Turk\n\n\nIt's worth signing up for Amazon Mechanical Turk (perhaps using your AWS account from above), both as a \nrequester\n and as a \nworker\n. You'll use this to test and monitor experiments. You should also sign in to each sandbox, \nrequester\n and \nworker\n using the same account. Store this account and password somewhere, but you don't need to tell it to Wallace.\n\n\npsiTurk\n\n\nNext, create an account on \npsiTurk\n, which will require a valid email address. Once you confirm your account, click on \nAPI Keys\n, which will allow you to access your API keys as seen in the image below:\n\n\n\n\nPlace these credential in the \n.wallaceconfig\n file:\n\n\nThen fill in the following lines of \n.wallaceconfig\n, replacing \n???\n with your keys:\n\n\n[psiTurk Access]\npsiturk_access_key_id = ???\npsiturk_secret_access_id = ???\n\n\n\nHeroku\n\n\nNext, sign up for \nHeroku\n and install the \nHeroku toolbelt\n. \n\n\nYou should see an interface that looks something like the following:\n\n\n\n\nThen, log in from the command line:\n\n\nheroku login\n\n\n\nAnd fill in the appropriate section of \n.wallaceconfig\n:\n\n\n[Heroku Access]\nheroku_email_address = ???\nheroku_password = ???\n\n\n\n\nDone?\n\n\nDone. You're now all set up with the tools you need to work with Wallace. \n\n\nNext, we'll \ntest Wallace to make sure it's working on your system\n.", 
            "title": "Keys for AWS, Heroku, etc."
        }, 
        {
            "location": "/AWS-etc-keys/#create-the-configuration-file", 
            "text": "The first step is to create the Wallace configuration file in your home directory. You can do this using the Wallace command-line utility through  wallace setup  which will prepopulate a hidden file  .wallaceconfig  in your home directory. Alternatively, you can create this file yourself and fill it in like so:  [AWS Access]\naws_access_key_id = ???\naws_secret_access_key = ???\naws_region = us-east-1\n\n[psiTurk Access]\npsiturk_access_key_id = ???\npsiturk_secret_access_id = ???\n\n[Heroku Access]\nheroku_email_address = ???\nheroku_password = ???\n\n[Email Access]\nwallace_email_address = ???\nwallace_email_password = ???\n\n[Task Parameters]\nexperiment_code_version = 1.0\nnum_conds = 1\nnum_counters = 1\n\n[Server Parameters]\nport = 5000\ncutoff_time = 30\nlogfile = -\nloglevel = 0\ndebug = true\nlogin_username = examplename\nlogin_pw = examplepassword\nthreads = 1\nclock_on = true  In the next steps, we'll fill in your config file with keys.", 
            "title": "Create the configuration file"
        }, 
        {
            "location": "/AWS-etc-keys/#amazon-web-services-api-keys", 
            "text": "You can get API keys for Amazon Web Services by  following these instructions .   Then fill in the following lines of  .wallaceconfig , replacing  ???  with your keys:  [AWS Access]\naws_access_key_id = ???\naws_secret_access_key = ???  N.B.  One feature of AWS API keys is that they are only displayed once, and though they can be regenerated, doing so will render invalid previously generated keys. If you are running experiments using a laboratory account (or any other kind of group-owned account), regenerating keys will stop other users who have previously generated keys from being able to use the AWS account. Unless you are sure that you will not be interrupting others' workflows, it is advised that you do  not  generate new API keys. If you are not the primary user of the account, see if you can obtain these keys from others who have successfully used AWS.", 
            "title": "Amazon Web Services API Keys"
        }, 
        {
            "location": "/AWS-etc-keys/#amazon-mechanical-turk", 
            "text": "It's worth signing up for Amazon Mechanical Turk (perhaps using your AWS account from above), both as a  requester  and as a  worker . You'll use this to test and monitor experiments. You should also sign in to each sandbox,  requester  and  worker  using the same account. Store this account and password somewhere, but you don't need to tell it to Wallace.", 
            "title": "Amazon Mechanical Turk"
        }, 
        {
            "location": "/AWS-etc-keys/#psiturk", 
            "text": "Next, create an account on  psiTurk , which will require a valid email address. Once you confirm your account, click on  API Keys , which will allow you to access your API keys as seen in the image below:   Place these credential in the  .wallaceconfig  file:  Then fill in the following lines of  .wallaceconfig , replacing  ???  with your keys:  [psiTurk Access]\npsiturk_access_key_id = ???\npsiturk_secret_access_id = ???", 
            "title": "psiTurk"
        }, 
        {
            "location": "/AWS-etc-keys/#heroku", 
            "text": "Next, sign up for  Heroku  and install the  Heroku toolbelt .   You should see an interface that looks something like the following:   Then, log in from the command line:  heroku login  And fill in the appropriate section of  .wallaceconfig :  [Heroku Access]\nheroku_email_address = ???\nheroku_password = ???", 
            "title": "Heroku"
        }, 
        {
            "location": "/AWS-etc-keys/#done", 
            "text": "Done. You're now all set up with the tools you need to work with Wallace.   Next, we'll  test Wallace to make sure it's working on your system .", 
            "title": "Done?"
        }, 
        {
            "location": "/Wallace-with-Anaconda/", 
            "text": "If you are interested in developing Wallace but already use \nAnaconda\n, you'll need to slightly adapt the standard instructions for Wallace.\n\n\nInstall Wallace\n\n\nYou'll follow all of the \nWallace development installation instructions\n, \nwith the exception of the virtual environment step\n.\n\n\nConfirm Wallace works\n\n\nNow, we need to make sure that Wallace and Anaconda play nice with one another. At this point, we'd check to make sure that Wallace is properly installed by typing\n\n\nwallace --version\n\n\n\n\ninto the command line. For those of us with Anaconda, we'll get a long error message. Don't panic! Add the following to your \n.bash_profile\n:\n\n\nexport DYLD_FALLBACK_LIBRARY_PATH=$HOME/anaconda/lib/:$DYLD_FALLBACK_LIBRARY_PATH\n\n\n\n\nIf you installed anaconda using \nPython 3\n, you will need to change  \nanaconda\n in that path to \nanaconda3\n. \n\n\nAfter you \nsource\n your \n.bash_profile\n, you can check your Wallace version (using the same command that we used earlier), which should return the Wallace version that you've installed.\n\n\nRe-link Open SSL\n\n\nFinally, you'll need to re-link \nopenssl\n. Run the following:\n\n\nbrew install --upgrade openssl\nbrew unlink openssl \n brew link openssl --force", 
            "title": "For users of Anaconda"
        }, 
        {
            "location": "/Wallace-with-Anaconda/#install-wallace", 
            "text": "You'll follow all of the  Wallace development installation instructions ,  with the exception of the virtual environment step .", 
            "title": "Install Wallace"
        }, 
        {
            "location": "/Wallace-with-Anaconda/#confirm-wallace-works", 
            "text": "Now, we need to make sure that Wallace and Anaconda play nice with one another. At this point, we'd check to make sure that Wallace is properly installed by typing  wallace --version  into the command line. For those of us with Anaconda, we'll get a long error message. Don't panic! Add the following to your  .bash_profile :  export DYLD_FALLBACK_LIBRARY_PATH=$HOME/anaconda/lib/:$DYLD_FALLBACK_LIBRARY_PATH  If you installed anaconda using  Python 3 , you will need to change   anaconda  in that path to  anaconda3 .   After you  source  your  .bash_profile , you can check your Wallace version (using the same command that we used earlier), which should return the Wallace version that you've installed.", 
            "title": "Confirm Wallace works"
        }, 
        {
            "location": "/Wallace-with-Anaconda/#re-link-open-ssl", 
            "text": "Finally, you'll need to re-link  openssl . Run the following:  brew install --upgrade openssl\nbrew unlink openssl   brew link openssl --force", 
            "title": "Re-link Open SSL"
        }, 
        {
            "location": "/Demoing-Wallace/", 
            "text": "First, make sure you have Wallace installed:\n\n\n\n\nInstallation instructions for users\n\n\nInstallation instructions for developers\n\n\n\n\nTo test out Wallace, we'll run an example experiment in debug mode. From a terminal within the Wallace directory, run\n\n\ncd examples/bartlett1932\nwallace debug\n\n\n\n\nYou will see some output as Wallace loads. When it is finished, you will see something that looks like:\n\n\nNow serving on http://0.0.0.0:5000\n[psiTurk server:on mode:sdbx #HITs:4]$\n\n\n\n\nThis is the psiTurk prompt. Into that prompt type:\n\n\ndebug\n\n\n\n\nThis will cause the experiment to open in a new window in your browser. Alternatively, type\n\n\ndebug --print-only\n\n\n\n\nto get the URL of the experiment so that you can view it on a different machine than the one you are serving it on. \n\n\nOnce you have finished running through the experiment as a participant, you can type \ndebug\n again to play as the next participant.\n\n\nHelp, the experiment page is blank!\n This may happen if you are using an ad-blocker. Try disabling your ad-blocker and refresh the page.", 
            "title": "Running a demo"
        }, 
        {
            "location": "/Command-line-utility/", 
            "text": "Wallace is executed from the command line within the experiment directory with the following commands: \n\n\n \nwallace verify\n\n\n \nwallace debug\n\n\n \nwallace sandbox\n\n\n \nwallace deploy\n\n\n \nwallace logs\n\n\n \nwallace status\n\n\n \nwallace export\n\n\n \nwallace summary\n\n\n \nwallace qualify\n\n\n \nwallace hibernate\n\n\n \nwallace awaken\n\n\n \nwallace create\n\n\nverify\n\n\nVerifies that a directory is a Wallace-compatible app.\n\n\ndebug\n\n\n--verbose\n \n\nRuns the experiment locally. If \n--verbose\n is included more detailed logs are printed to the command line.\n\n\nsandbox\n\n\n--verbose\n \n\n\n--app \nname\n \n\nRuns the experiment on MTurk's sandbox using Heroku as a server. If \n--verbose\n is included more detailed logs are printed to the command line. If \n--app\n is specified the app on heroku will have that name.\n\n\ndeploy\n\n\n--verbose\n \n\n\n--app \nname\n \n\nRuns the experiment live on MTurk using Heroku as a server. If \n--verbose\n is included more detailed logs are printed to the command line. If \n--app\n is specified the app on heroku will have that name.\n\n\nlogs\n\n\n--app \napp\n \n\nOpens the app's logs in Papertrail.\n\n\nstatus\n\n\nReturns the status of an experiment.\n\n\nexport\n\n\nDownloads the database and partial server logs to a zipped folder within the data directory of the experimental folder. Databases are stored in csv format.\n\n\nsummary\n\n\n--app \napp-id\n \n\nPrints a summary of the participant table to the command line. You must specify the app id.\n\n\nqualify\n\n\n--qualification \nqualification_id\n \n\n\n--value \nvalue\n \n\n\n--worker \nworker_id\n \n\nAssigns qualification \nqualification_id\n with value \nvalue\n to worker \nworker_id\n. This is useful when compensating workers if something goes wrong with the experiment.\n\n\nhibernate\n\n\n--app \napp\n \n\nTemporarily scales down the specified app to save money. All dynos are removed and so are many of the add-ons. Hibernating apps are non-functional. It is likely that the app will not be entirely free while hibernating. To restore the app use \nawaken\n.\n\n\nawaken\n\n\n--app \napp\n \n\nRetore a hibernating app.\n\n\ncreate\n\n\n--example \ndemo\n \n\nCopies the \ndemo\n experiment from the examples directory to the command line location. \ndemo\n must be the name of a directory with the examples directory. The default is \nbartlett1932\n.", 
            "title": "Command-line utility"
        }, 
        {
            "location": "/Command-line-utility/#verify", 
            "text": "Verifies that a directory is a Wallace-compatible app.", 
            "title": "verify"
        }, 
        {
            "location": "/Command-line-utility/#debug", 
            "text": "--verbose   \nRuns the experiment locally. If  --verbose  is included more detailed logs are printed to the command line.", 
            "title": "debug"
        }, 
        {
            "location": "/Command-line-utility/#sandbox", 
            "text": "--verbose    --app  name   \nRuns the experiment on MTurk's sandbox using Heroku as a server. If  --verbose  is included more detailed logs are printed to the command line. If  --app  is specified the app on heroku will have that name.", 
            "title": "sandbox"
        }, 
        {
            "location": "/Command-line-utility/#deploy", 
            "text": "--verbose    --app  name   \nRuns the experiment live on MTurk using Heroku as a server. If  --verbose  is included more detailed logs are printed to the command line. If  --app  is specified the app on heroku will have that name.", 
            "title": "deploy"
        }, 
        {
            "location": "/Command-line-utility/#logs", 
            "text": "--app  app   \nOpens the app's logs in Papertrail.", 
            "title": "logs"
        }, 
        {
            "location": "/Command-line-utility/#status", 
            "text": "Returns the status of an experiment.", 
            "title": "status"
        }, 
        {
            "location": "/Command-line-utility/#export", 
            "text": "Downloads the database and partial server logs to a zipped folder within the data directory of the experimental folder. Databases are stored in csv format.", 
            "title": "export"
        }, 
        {
            "location": "/Command-line-utility/#summary", 
            "text": "--app  app-id   \nPrints a summary of the participant table to the command line. You must specify the app id.", 
            "title": "summary"
        }, 
        {
            "location": "/Command-line-utility/#qualify", 
            "text": "--qualification  qualification_id    --value  value    --worker  worker_id   \nAssigns qualification  qualification_id  with value  value  to worker  worker_id . This is useful when compensating workers if something goes wrong with the experiment.", 
            "title": "qualify"
        }, 
        {
            "location": "/Command-line-utility/#hibernate", 
            "text": "--app  app   \nTemporarily scales down the specified app to save money. All dynos are removed and so are many of the add-ons. Hibernating apps are non-functional. It is likely that the app will not be entirely free while hibernating. To restore the app use  awaken .", 
            "title": "hibernate"
        }, 
        {
            "location": "/Command-line-utility/#awaken", 
            "text": "--app  app   \nRetore a hibernating app.", 
            "title": "awaken"
        }, 
        {
            "location": "/Command-line-utility/#create", 
            "text": "--example  demo   \nCopies the  demo  experiment from the examples directory to the command line location.  demo  must be the name of a directory with the examples directory. The default is  bartlett1932 .", 
            "title": "create"
        }, 
        {
            "location": "/Monitoring-a-live-experiment/", 
            "text": "There are a number of ways that you can monitor a live experiment:\n\n\nCommand line tools\n\n\nwallace summary --app {#id}\n, where \n{#id}\n is the id (\nw...\n) of the application.\n\n\nThis will print a summary showing the number of participants with each status code, as well as the overall yield:\n\n\nstatus  | count\n----------------\n1   | 26\n101 | 80\n103 | 43\n104 | 2\n\nYield: 64.00%\n\n\n\n\nPapertrail\n\n\nYou can use Papertrail to view and search the live logs of your experiment. You can access the logs either through the Heroku dashboard's Resources panel (https://dashboard.heroku.com/apps/{#id}/resources), where {#id} is the id of your experiment, or directly through papertrail.com (https://papertrailapp.com/systems/{#id}/events).\n\n\nSetting up alerts\n\n\nYou can set up Papertrail to send error notifications to Slack or another communications platform.\n\n\n\n\nTake a deep breath.\n\n\nOpen the Papertrail logs.\n\n\nSearch for the term \nerror\n.\n\n\nTo the right of the search bar, you will see a button titled \"+ Save Search\". Click it. Name the search \"Errors\". Then click \"Save \n Setup an Alert\", which is to the right of \"Save Search\".\n\n\nYou will be directed to a page with a list of services that you can use to set up an alert.\n\n\nClick, e.g., Slack.\n\n\nChoose the desired frequency of alert. We recommend the minimum, 1 minute.\n\n\nUnder the heading \"Slack details\", open (\nin a new tab or window\n) the link \nnew Papertrail integration\n.\n\n\nThis will bring you to a Slack page where you will choose a channel to post to. You may need to log in.\n\n\nSelect the desired channel.\n\n\nClick \"Add Papertrail Integration\".\n\n\nYou will be brought to a page with more information about the integration. \n\n\nScroll down to Step 3 to get the Webhook URL. It should look something like \nhttps://hooks.slack.com/services/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\n.\n\n\nCopy this link to your clipboard.\n\n\nChange anything else you want and then scroll to the bottom and click \"Save integration\".\n\n\nGo back to Papertrail page that you left in Step 7.\n\n\nPaste the copied URL into the input text box labeled \"Integration's Webook URL\" under the \"Slack Details\" heading.\n\n\nClick \"Create Alert\" on the same page.\n\n\nVictory.", 
            "title": "Monitoring a live experiment"
        }, 
        {
            "location": "/Monitoring-a-live-experiment/#command-line-tools", 
            "text": "wallace summary --app {#id} , where  {#id}  is the id ( w... ) of the application.  This will print a summary showing the number of participants with each status code, as well as the overall yield:  status  | count\n----------------\n1   | 26\n101 | 80\n103 | 43\n104 | 2\n\nYield: 64.00%", 
            "title": "Command line tools"
        }, 
        {
            "location": "/Monitoring-a-live-experiment/#papertrail", 
            "text": "You can use Papertrail to view and search the live logs of your experiment. You can access the logs either through the Heroku dashboard's Resources panel (https://dashboard.heroku.com/apps/{#id}/resources), where {#id} is the id of your experiment, or directly through papertrail.com (https://papertrailapp.com/systems/{#id}/events).", 
            "title": "Papertrail"
        }, 
        {
            "location": "/Monitoring-a-live-experiment/#setting-up-alerts", 
            "text": "You can set up Papertrail to send error notifications to Slack or another communications platform.   Take a deep breath.  Open the Papertrail logs.  Search for the term  error .  To the right of the search bar, you will see a button titled \"+ Save Search\". Click it. Name the search \"Errors\". Then click \"Save   Setup an Alert\", which is to the right of \"Save Search\".  You will be directed to a page with a list of services that you can use to set up an alert.  Click, e.g., Slack.  Choose the desired frequency of alert. We recommend the minimum, 1 minute.  Under the heading \"Slack details\", open ( in a new tab or window ) the link  new Papertrail integration .  This will bring you to a Slack page where you will choose a channel to post to. You may need to log in.  Select the desired channel.  Click \"Add Papertrail Integration\".  You will be brought to a page with more information about the integration.   Scroll down to Step 3 to get the Webhook URL. It should look something like  https://hooks.slack.com/services/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 .  Copy this link to your clipboard.  Change anything else you want and then scroll to the bottom and click \"Save integration\".  Go back to Papertrail page that you left in Step 7.  Paste the copied URL into the input text box labeled \"Integration's Webook URL\" under the \"Slack Details\" heading.  Click \"Create Alert\" on the same page.  Victory.", 
            "title": "Setting up alerts"
        }, 
        {
            "location": "/Postico-and-Postgres/", 
            "text": "Postico is a nice tool for examining Postgres databases on OS X. We use it to connect to live experiment databases. Here are the steps needed to do this:\n\n\n\n\nDownload \nPostico\n and place it in your Applications folder.\n\n\nOpen Postico.\n\n\nPress the \"New Favorite\" button in the bottom left corner to access a new database.\n\n\nGet the database credentials from the Heroku dashboard:\n\n\nGo to https://dashboard.heroku.com/apps/{app_id}/resources\n\n\nUnder the \nAdd-ons\n subheading, go to \"Heroku Postgres :: Database\"\n\n\nNote the database credentials under the subheading \"Connection Settings\". You'll use these in step 5.\n\n\n\n\n\n\nFill in the database settings in Postico. You'll need to include the:\n\n\nHost\n\n\nPort\n\n\nUser\n\n\nPassword\n\n\nDatabase\n\n\n\n\n\n\nConnect to the database.\n\n\nYou may see a dialog box pop up saying that Postico cannot verify the identity of the server. Click \"Connect\" to proceed.", 
            "title": "Examining the database"
        }, 
        {
            "location": "/demos/bartlett1932/", 
            "text": "Frederic Bartlett's 1932 book \nRemembering\n documents early experiments that explore how using and transmitting a memory can affect the memory\u2019s contents. Bartlett wanted to understand how culture shapes memory. Inspired by Philippe (1897), he performed a series of experiments that asked participants to repeatedly recall a memory or to pass it down a chain of people, from one to the next. Bartlett showed that the process of reproduction alters memories over time, causing them to take on features from an individual\u2019s culture. More generally, the methods he developed expose cumulative effects of the forces that reshape and degrade memories and how they impact the structure and veracity of what we remember.\n\n\nBartlett, F. C. (1932). Remembering. Cambridge: Cambridge University Press.\n\n\nIn this demo, a story is passed down a chain.\n\n\nDownload the demo\n.", 
            "title": "War of the Ghosts"
        }, 
        {
            "location": "/demos/function-learning/", 
            "text": "Culturally transmitted knowledge changes as it is transmitted from person to person. Some of the most striking instances of this process come from cases of language acquisition. For example, in Nicaragua, a community of deaf children transformed a fragmentary pidgin into a language with rich grammatical struc- ture by learning from each other (Kegl and Iwata, 1989; Senghas and Coppola, 2001). Languages, legends, and social norms are all shaped by the processes of cultural transmission (Cavalli-Sforza, 1981; Boyd and Richerson, 1988; Kirby, 1999, 2001; Briscoe, 2002).\n\n\nLaboratory studies of cultural transmission often use the method of \u201citerated learning\u201d, which has roots in \nBartlett\u2019s experiments\n. In the iterated learning paradigm, information is passed along a chain of individuals, from one to the next, much like in the children\u2019s game Telephone. Iterated learning paradigms for the transmission of language and other forms of knowledge have been developed, too (Kalish et al., 2007; Griffiths and Kalish, 2007; Griffiths et al., 2008a). For example, in one study, participants learned the relationship between two continuous variables (\u201cfunction learning\u201d) and were tested on what they had discovered (Kalish et al., 2007). Responses on the test were then used to train the next participant in the chain. Kalish et al. (2007) found that, over time, knowledge transmitted through the chain reverts to the prior beliefs of the individual learners.\n\n\nKalish, M. L., Griffiths, T. L., \n Lewandowsky, S. (2007). Iterated learning: Intergenerational knowledge transmission reveals inductive biases. Psychonomic Bulletin and Review, 14, 288-294.\n\n\nDownload the demo\n.", 
            "title": "Transmitting functions"
        }, 
        {
            "location": "/demos/mcmcp/", 
            "text": "Markov Chain Monte Carlo with People (MCMCP) is a method for uncovering  mental representations that exploits an equivalence between a model of\nhuman choice behavior and an element of an MCMC algorithm. This demo replicates Experiment 3 of Sanborn, Griffiths, \n Shiffrin (2010), which applies MCMCP to four natural categories, providing estimates of the distributions over animal shapes that people associate with giraffes, horses, cats, and dogs.\n\n\nSanborn, A. N., Griffiths, T. L., \n Shiffrin, R. M. (2010). Uncovering mental representations with Markov chain Monte Carlo. \nCognitive Psychology\n, 60(2), 63-106.\n\n\nDownload the demo\n.", 
            "title": "Markov Chain Monte Carlo with people"
        }, 
        {
            "location": "/demos/chatroom/", 
            "text": "This is a networked coordination game where players broadcast messages to eachother and try to make the same decision as others.\n\n\nDownload the demo\n.", 
            "title": "Chatroom-based coordination game"
        }, 
        {
            "location": "/demos/rogers/", 
            "text": "This experiment, which demonstrates Rogers paradox, explores the evolution of asocial learning and unguided social learning in the context of a numerical discrimination task.\n\n\nDownload the demo\n.", 
            "title": "Rogers paradox"
        }, 
        {
            "location": "/Required-experimental-files/", 
            "text": "Wallace is flexible with regards to the form the front end takes. However, there are a number of required or forbidden files. You can verify that a directory is compatible by running \nwallace verify\n from a terminal within the directory. Though just because these checks pass doesn't mean the experiment will run! The minimal required structure is as follows:\n\n\n\n\nBlue items are (optional) directories (note that the experiment directory can have any name), green items are required files (the README file can be either a txt file or a md file), and red items are forbidden files that will cause a conflict at run time. \n\n\nRequired files\n\n\n\n\n\n\nconfig.txt - The config file contains a variety of parameters that affect how Wallace runs. For more info see...\n\n\n\n\n\n\nexperiment.py - This is a python file containing the custom experiment code.\n\n\n\n\n\n\nREADME.txt/md - This (hopefully) contains a helpful description of the experiment.\n\n\n\n\n\n\nForbidden files\n\n\nA number of files cannot be included in the experiment directory. This is because, when Wallace runs, it inserts a number of required files into the experiment directory and will overwrite any files with the same name. The files are as follows:\n\n\n\n\ncomplete.html - this html page shows when wallace is run in debug mode and the experiment is complete.\n\n\nerror_wallace.html - this is a flexible error page that shows when something goes wrong.\n\n\nlaunch.html - this page is shown when the /launch route is pinged and the experiment starts successfully.\n\n\nrobots.txt - this file is returned to bots (e.g. from google) that bump into the experiment when crawling the internet.\n\n\nwallace.js - this is a javascript library with a number of helpful functions.\n\n\nreqwest.min.js\n - this is required for wallace.js to work.\n\n\nwallace.css - this contains several css classes that are used in the examples.", 
            "title": "Required experimental files"
        }, 
        {
            "location": "/Required-experimental-files/#required-files", 
            "text": "config.txt - The config file contains a variety of parameters that affect how Wallace runs. For more info see...    experiment.py - This is a python file containing the custom experiment code.    README.txt/md - This (hopefully) contains a helpful description of the experiment.", 
            "title": "Required files"
        }, 
        {
            "location": "/Required-experimental-files/#forbidden-files", 
            "text": "A number of files cannot be included in the experiment directory. This is because, when Wallace runs, it inserts a number of required files into the experiment directory and will overwrite any files with the same name. The files are as follows:   complete.html - this html page shows when wallace is run in debug mode and the experiment is complete.  error_wallace.html - this is a flexible error page that shows when something goes wrong.  launch.html - this page is shown when the /launch route is pinged and the experiment starts successfully.  robots.txt - this file is returned to bots (e.g. from google) that bump into the experiment when crawling the internet.  wallace.js - this is a javascript library with a number of helpful functions.  reqwest.min.js  - this is required for wallace.js to work.  wallace.css - this contains several css classes that are used in the examples.", 
            "title": "Forbidden files"
        }, 
        {
            "location": "/The-Experiment-class/", 
            "text": "Experiments are designed in Wallace by creating a custom subclass of the base Experiment class. The code for the Experiment class is in experiments.py. Unlike the \nother classes\n, each experiment involves only a single Experiment object and it is not stored as an entry in a corresponding table, rather each Experiment is a set of instructions that tell the server what to do with the database when the server receives requests from outside.\n\n\nAttributes\n\n\n\n\nverbose - Boolean, determines whether the experiment logs output when running. Default is True.\n\n\ntask - String, the name of the experiment. Default is \"Experiment title\".\n\n\nsession - session, the experiment's connection to the database.\n\n\npractice_repeats - int, the number of practice networks (see \nNetwork.role\n). Default is 0.\n\n\nexperiment_repeats - int, the number of non practice networks (see \nNetwork.role\n). Default is 0.\n\n\nrecruiter - Recruiter, the Wallace class that recruits participants. Default is PsiTurkRecruiter.\n\n\ninitial_recruitment_size - int, the number of participants requested when the experiment first starts. Default is 1.\n\n\nknown_classes - dictionary, the classes Wallace can make in response to front-end requests. Experiments can add new classes to this dictionary.\n\n\n\n\nFunctions\n\n\nexperiment\n.__init__\n(\nsession\n) \n\nCreate the experiment class. Sets the value of attributes, see above.\n\n\nexperiment\n.add_node_to_network\n(\nnode, network\n) \n\nPass the \nnode\n to \nnetwork.add_node()\n.\n\n\nexperiment\n.assignment_abandoned\n(\nparticipant\n) \n\nRuns when a notification from AWS is received indicating that \nparticipant\n has run out of time. Calls fail_participant.\n\n\nexperiment\n.assignment_returned\n(\nparticipant\n) \n\nRuns when a notification from AWS is received indicating that \nparticipant\n has returned the experiment assignment. Calls fail_participant.\n\n\nexperiment\n.attention_check\n(\nparticipant\n) \n\nReturn a boolean value indicating whether the \nparticipant\n's data is acceptable. This is mean to check the participant's data to determine that they paid attention. This check will run once the \nparticipant\n completes the experiment. By default performs no checks and returns True. See also experiment.data_check().\n\n\nexperiment\n.attention_check_failed\n(\nparticipant\n) \n\nRuns when \nparticipant\n has failed the attention_check. By default calls fail_participant.\n\n\nexperiment\n.bonus\n(\nparticipant\n) \n\nReturn the value of the bonus to be paid to \nparticipant\n. By default returns 0.\n\n\nexperiment\n.bonus_reason\n(\nparticipant\n)\nReturn a string that will be included in an email sent to the \nparticipant\n receiving a bonus. By default it is \"Thank you for participant! Here is your bonus.\"\n\n\nexperiment\n.create_network\n()\nReturn a new network. By default, the type of network is determined by experiment.network_type(). If the experiment uses networks of different types, or needs to pass argument to the network's \ninit\n() method, this function should be overwritten. Otherwise, it is simpler to overwrite network_type().\n\n\nexperiment\n.create_node\n(\nparticipant, network\n)\nReturn a new node associated with the \nparticipant\n and in \nnetwork\n. By default, the type of node is determined by experiment.node_type(). If the experiment uses nodes of different types, or needs to pass argument to the node's \ninit\n() method, this function should be overwritten. Otherwise, it is simpler to overwrite node_type().\n\n\nexperiment\n.data_check\n(\nparticipant\n) \n\nReturn a boolean value indicating whether the \nparticipant\n's data is acceptable. This is meant to check for missing or invalid data. This check will be run once the \nparticipant\n completes the experiment. By default performs no checks and returns True. See also, experiment.attention_check().\n\n\nexperiment\n.data_check_failed\n(\nparticipant\n) \n\nRuns when \nparticipant\n has failed the data_check. By default calls fail_participant.\n\n\nexperiment\n.fail_participant\n(\nparticipant\n) \n\nInstruct all \nparticipant\n's unfailed nodes to fail.\n\n\nexperiment\n.get_network_for_participant\n(\nparticipant\n) \n\nReturn a network that the \nparticipant\n can join. If not networks are available returns None. By default participants can participate only once in each network and participants first complete networks with role=\"practice\" before doing all other networks in a random order.\n\n\nexperiment\n.info_get_request\n(\nnode, infos\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to get infos.\n\n\nexperiment\n.info_post_request\n(\nnode, info\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to make an info.\n\n\nexperiment\n.log\n(\ntext, [key, force]\n) \n\nPrint \ntext\n to the logs. \nkey\n will be appended to text. Logging is suppressed if verbose=False, but will still occur if \nforce\n=True (by default it is False).\n\n\nexperiment\n.log_summary\n() \n\nPrint a summary of participant statuses.\n\n\nexperiment\n.networks\n(\n[role, full]\n) \n\nReturn a list of networks. Can filter by \nrole\n (String) and \nfull\n (Boolean), both default to \"all\".\n\n\nexperiment\n.node_get_request\n(\nparticipant, [node, nodes]\n) \n\nOverwritable method that runs after a request from the front-end from \nparticipant\n to get a node/nodes.\n\n\nexperiment\n.node_post_request\n(\nparticipant, node\n) \n\nOverwritable method that runs after a request from the front-end from \nparticipant\n to make a node.\n\n\nexperiment\n.network_type\n() \n\nReturn the class of network to be created. See create_network().\n\n\nexperiment\n.node_type\n() \n\nReturn the class of node to be created. See create_node().\n\n\nexperiment\n.recruit\n() \n\nRecruit more participants. This method runs whenever a participant successfully completes the experiment (participants who fail to finish successfully are automatically replaced). By default it recruits 1 participant at a time until all networks are full.\n\n\nexperiment\n.save\n(objects) \n\nAdd \nobjects\n to the database and then commit. This only needs to be done for networks and participants.\n\n\nexperiment\n.setup\n() \n\nCreate networks if none are present.\n\n\nexperiment\n.submission_successful\n(\nparticipant\n) \n\nOverwritable method that runs after the \nparticipant\n completes the experiment and passes the data_check and attention_check(). By default does nothing.\n\n\nexperiment\n.transformation_get_request\n(\nnode, transformations\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to get transformations.\n\n\nexperiment\n.transformation_post_request\n(\nnode, transformation\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to make a transformation.\n\n\nexperiment\n.transmission_get_request\n(\nnode, transmissions\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to get transmissions.\n\n\nexperiment\n.transmission_post_request\n(\nnode, transmission\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to send a transmission.\n\n\nexperiment\n.vector_get_request\n(\nnode, vectors\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to get vectors.\n\n\nexperiment\n.vector_post_request\n(\nnode, vector\n) \n\nOverwritable method that runs after a request from the front-end from \nnode\n to make a vector.", 
            "title": "The Experiment Class"
        }, 
        {
            "location": "/The-Experiment-class/#attributes", 
            "text": "verbose - Boolean, determines whether the experiment logs output when running. Default is True.  task - String, the name of the experiment. Default is \"Experiment title\".  session - session, the experiment's connection to the database.  practice_repeats - int, the number of practice networks (see  Network.role ). Default is 0.  experiment_repeats - int, the number of non practice networks (see  Network.role ). Default is 0.  recruiter - Recruiter, the Wallace class that recruits participants. Default is PsiTurkRecruiter.  initial_recruitment_size - int, the number of participants requested when the experiment first starts. Default is 1.  known_classes - dictionary, the classes Wallace can make in response to front-end requests. Experiments can add new classes to this dictionary.", 
            "title": "Attributes"
        }, 
        {
            "location": "/The-Experiment-class/#functions", 
            "text": "experiment .__init__ ( session )  \nCreate the experiment class. Sets the value of attributes, see above.  experiment .add_node_to_network ( node, network )  \nPass the  node  to  network.add_node() .  experiment .assignment_abandoned ( participant )  \nRuns when a notification from AWS is received indicating that  participant  has run out of time. Calls fail_participant.  experiment .assignment_returned ( participant )  \nRuns when a notification from AWS is received indicating that  participant  has returned the experiment assignment. Calls fail_participant.  experiment .attention_check ( participant )  \nReturn a boolean value indicating whether the  participant 's data is acceptable. This is mean to check the participant's data to determine that they paid attention. This check will run once the  participant  completes the experiment. By default performs no checks and returns True. See also experiment.data_check().  experiment .attention_check_failed ( participant )  \nRuns when  participant  has failed the attention_check. By default calls fail_participant.  experiment .bonus ( participant )  \nReturn the value of the bonus to be paid to  participant . By default returns 0.  experiment .bonus_reason ( participant )\nReturn a string that will be included in an email sent to the  participant  receiving a bonus. By default it is \"Thank you for participant! Here is your bonus.\"  experiment .create_network ()\nReturn a new network. By default, the type of network is determined by experiment.network_type(). If the experiment uses networks of different types, or needs to pass argument to the network's  init () method, this function should be overwritten. Otherwise, it is simpler to overwrite network_type().  experiment .create_node ( participant, network )\nReturn a new node associated with the  participant  and in  network . By default, the type of node is determined by experiment.node_type(). If the experiment uses nodes of different types, or needs to pass argument to the node's  init () method, this function should be overwritten. Otherwise, it is simpler to overwrite node_type().  experiment .data_check ( participant )  \nReturn a boolean value indicating whether the  participant 's data is acceptable. This is meant to check for missing or invalid data. This check will be run once the  participant  completes the experiment. By default performs no checks and returns True. See also, experiment.attention_check().  experiment .data_check_failed ( participant )  \nRuns when  participant  has failed the data_check. By default calls fail_participant.  experiment .fail_participant ( participant )  \nInstruct all  participant 's unfailed nodes to fail.  experiment .get_network_for_participant ( participant )  \nReturn a network that the  participant  can join. If not networks are available returns None. By default participants can participate only once in each network and participants first complete networks with role=\"practice\" before doing all other networks in a random order.  experiment .info_get_request ( node, infos )  \nOverwritable method that runs after a request from the front-end from  node  to get infos.  experiment .info_post_request ( node, info )  \nOverwritable method that runs after a request from the front-end from  node  to make an info.  experiment .log ( text, [key, force] )  \nPrint  text  to the logs.  key  will be appended to text. Logging is suppressed if verbose=False, but will still occur if  force =True (by default it is False).  experiment .log_summary ()  \nPrint a summary of participant statuses.  experiment .networks ( [role, full] )  \nReturn a list of networks. Can filter by  role  (String) and  full  (Boolean), both default to \"all\".  experiment .node_get_request ( participant, [node, nodes] )  \nOverwritable method that runs after a request from the front-end from  participant  to get a node/nodes.  experiment .node_post_request ( participant, node )  \nOverwritable method that runs after a request from the front-end from  participant  to make a node.  experiment .network_type ()  \nReturn the class of network to be created. See create_network().  experiment .node_type ()  \nReturn the class of node to be created. See create_node().  experiment .recruit ()  \nRecruit more participants. This method runs whenever a participant successfully completes the experiment (participants who fail to finish successfully are automatically replaced). By default it recruits 1 participant at a time until all networks are full.  experiment .save (objects)  \nAdd  objects  to the database and then commit. This only needs to be done for networks and participants.  experiment .setup ()  \nCreate networks if none are present.  experiment .submission_successful ( participant )  \nOverwritable method that runs after the  participant  completes the experiment and passes the data_check and attention_check(). By default does nothing.  experiment .transformation_get_request ( node, transformations )  \nOverwritable method that runs after a request from the front-end from  node  to get transformations.  experiment .transformation_post_request ( node, transformation )  \nOverwritable method that runs after a request from the front-end from  node  to make a transformation.  experiment .transmission_get_request ( node, transmissions )  \nOverwritable method that runs after a request from the front-end from  node  to get transmissions.  experiment .transmission_post_request ( node, transmission )  \nOverwritable method that runs after a request from the front-end from  node  to send a transmission.  experiment .vector_get_request ( node, vectors )  \nOverwritable method that runs after a request from the front-end from  node  to get vectors.  experiment .vector_post_request ( node, vector )  \nOverwritable method that runs after a request from the front-end from  node  to make a vector.", 
            "title": "Functions"
        }, 
        {
            "location": "/Classes/", 
            "text": "The classes involved in a Wallace experiment are: \nNetwork\n, \nNode\n, \nVector\n, \nInfo\n, \nTransmission\n, \nTransformation\n, \nParticipant\n and \nQuestion\n. The code for all these classes can be seen in \nmodels.py\n. Each class has a corresponding table in the database, with each instance stored as a row in the table. Accordingly, each class is defined, in part, by the columns that constitute the table it is stored in. In addition, the classes have relationships to other objects and a number of functions.\n\n\nThe classes have relationships to each other as shown in the diagram below. Be careful to note which way the arrows point. A \nNode\n is a point in a \nNetwork\n that might be associated with a \nParticipant\n. A \nVector\n is a directional connection between a \nNode\n and another \nNode\n. An \nInfo\n is information created by a \nNode\n. A \nTransmission\n is an instance of an \nInfo\n being sent along a \nVector\n. A \nTransformation\n is a relationship between an \nInfo\n and another \nInfo\n. A \nQuestion\n is a survey response created by a \nParticipant\n.\n\n\n\n\nNetwork\n\n\nThe \nNetwork\n object can be imagined as a set of other objects with some functions that perform operations over those objects. The objects that \nNetwork\ns have direct access to are all the \nNode\ns in the network, the \nVector\ns between those Nodes, Infos created by those Nodes, Transmissions sent along the Vectors by those Nodes and Transformations of those Infos. Participants and Questions do not exist within Networks. An experiment may involve multiple Networks, Transmissions can only occur within networks, not between them.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Network was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Network has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"network\". This allows subclassing.\n\n\nmax_size\n - the maximum number of Nodes the Network can contain.\n\n\nfull\n - a boolean indicating whether the network has reached its max_size.\n\n\nrole\n - a String identifying the purpose of the Network. Any value can be used, but by default Wallace treats Networks with a role of \"practice\" differently.\n\n\n\n\nRelationships\n\n\n\n\nall_nodes\n - all the Nodes in the network. \n\n\nall_vectors\n - all the Vectors in the network.\n\n\nall_infos\n - all the Infos in the network.\n\n\nnetworks_transmissions\n - all the Transmissions in the network.\n\n\nnetworks_transformations\n - all the Transformations in the network.\n\n\n\n\nFunctions\n\n\nNetwork.__repr__()\n \n\nReturn a simple string representation of the network.\n\n\nNetwork.__json__()\n \n\nReturn a json object with all the attributes of the network.\n\n\nNetwork.calculate_full()\n \n\nUpdate attribute network.full to reflect current network size.\n\n\nNetwork.fail()\n \n\nSet \nnetwork.failed\n to True and \nnetwork.time_of_death\n to \nnow\n. Instruct all not-failed nodes in the network to fail.\n\n\nNetwork.infos([type, failed])\n \n\nReturn a list of infos in the network (i.e., infos made by nodes in the network). If specified, \ntype\n filters by class. By default failed infos are excluded, to include only failed infos use \nfailed=True\n, for all infos use \nfailed=\"all\"\n.\n\n\nnetwork\n.latest_transmission_recipient()\n \n\nReturn the node that most recently received a transmission.\n\n\nnetwork\n.nodes\n([\ntype, failed, participant_id\n]) \n\nReturn a list of nodes in the network. If specified, \ntype\n filters by class and \nparticipant_id\n filters by the nodes' associated participants. By default failed nodes are excluded, to include only failed nodes use \nfailed=True\n, for all nodes use \nfailed=\"all\"\n.\n\n\nnetwork\n.print_verbose()\n \n\nPrint a verbose description of the network.\n\n\nnetwork\n.size\n([\ntype, failed\n]) \n\nReturn the number of nodes in the network. If specified, \ntype\n filters by class. By default failed nodes are excluded, to include only failed nodes use \nfailed=True\n, for all nodes use \nfailed=\"all\"\n.\n\n\nnetwork\n.transformations\n([\ntype, failed\n]) \n\nReturn a list of transformations in the network (i.e., transformations by nodes in the network). If specified, \ntype\n filters by class. By default failed transformations are excluded, to include only failed transformations use \nfailed=True\n, for all transformations use \nfailed=\"all\"\n.\n\n\nnetwork\n.transmissions\n([\nstatus, failed\n]) \n\nReturn a list of transmissions in the network. \nstatus\n can be \"pending\" or \"received\" (default is \"all\"). By default failed transmissions are excluded, to include only failed transmissions use \nfailed=True\n, for all transmissions use \nfailed=\"all\"\n.\n\n\nnetwork\n.vectors\n([\nfailed\n]) \n\nReturn a list of vectors in the network. By default failed vectors are excluded, to include only failed vectors use \nfailed=True\n, for all vectors use \nfailed=\"all\"\n.\n\n\nNode\n\n\nEach Node represents a single point in a single network. A Node must be within a Network and may also be associated with a Participant.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Node was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Node has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"node\". This allows subclassing.\n\n\nnetwork_id\n - the id of the network the node is in.\n\n\nparticipant_id\n - the id of the participant the node is associated with.\n\n\n\n\nRelationships\n\n\n\n\nnetwork\n - the network the node is in.\n\n\nparticipant\n - the participant the node is associated with.\n\n\nall_outgoing_vectors\n - all the vectors going out from this Node.\n\n\nall_incoming_vectors\n - all the vectors coming in to this Node.\n\n\nall_infos\n - all Infos created by this Node.\n\n\nall_outgoing_transmissions\n - all Transmissions sent from this Node.\n\n\nall_incoming_transmissions\n - all Transmissions sent to this Node.\n\n\ntransformations_here\n - all transformations that took place at this Node.\n\n\n\n\nMethods\n\n\nnode.\n__repr__()\n \n\nReturn a simple string representation of the node.\n\n\nnode\n.__json__()\n \n\nReturn a json object with all the attributes of the node.\n\n\nnode.\n_to_whom()\n \n\nReturn the default value of \nto_whom\n for node.transmit(). Should not return None or a list containing None.\n\n\nnode.\n_what()\n \n\nReturn the default value of \nwhat\n for node.transmit(). Should not return None or a list containing None.\n\n\nnode.\nconnect\n(\nwhom\n, [\ndirection\n]) \n\nReturn a list of newly created vector between the node and whom. \nWhom\n can be a specific node or a (nested) list of nodes. Nodes can only connect with nodes in the same network. In addition nodes cannot connect with themselves or with Sources. \nDirection\n specifies the direction of the connection it can be \"to\" (node -\n whom), \"from\" (whom -\n node) or both (node \n-\n whom). The defult is \"to\".\n\n\nnode\n.fail()\n \n\nSet node.failed to True and node.time_of_death to now. Instruct all not-failed vectors connected to this node, infos made by this node, transmissions to or from this node and transformations made by this node to fail.\n\n\nnode.\nis_connected\n(\nwhom\n, [\ndirection\n]) \n\nReturn a (list of) boolean(s) indicating whether the node has a connection to \nwhom\n. \nWhom\n can be a single other node or a list of other nodes, if the former return a boolean, if the latter return a list of booleans. \nDirection\n specifies whether the required direction of the connection. The default value is \"to\", other values are \"from\", \"both\" and \"either\". Note that this method does not take a \nfailed\n argument and it will only look along not failed vectors.\n\n\nnode\n.infos\n([\ntype, failed\n]) \n\nReturn a list of infos created by the node. If specified, \ntype\n filters by class. By default failed infos are excluded, to include only failed infos use \nfailed=True\n, for all infos use \nfailed=\"all\"\n.\n\n\nnode.\nmutate\n(\ninfo_in\n) \n\nMutate the \ninfo_in\n - create a new info of the same type with its contents determined by info_in.mutated_contents() and then create a Mutation (a subclass of Transformation) linking the two.\n\n\nnode.\nneighbors\n([\ntype\n, \ndirection\n]) \n\nReturn a list of other nodes with an immediate connection to this node. If specified, \ntype\n filters neighboring nodes by class. \nDirection\n specifies the direction of the connection and can be \"to\", \"from\", \"both\" or \"either\"; the default value is \"to\". Note that a \nfailed\n argument should not be passed to node.neighbors() and the function only returns not failed nodes connected by not failed vectors.\n\n\nnode.\nreceive\n([\nwhat\n]) \n\nReceive incoming transmissions. \nWhat\n specifies what to receive. It can be a specific transmission. If \nwhat\n is not specified all pending transmissions are received. Received transmissions have their status set to \"received\" and their receive_time set to now. A list of all the infos associated with the received transmissions is passed to node.update().\n\n\nnode\n.received_infos\n([\ntype\n]) \n\nReturn a list of infos received by the node (i.e., transmitted to the node and received). If specified, \ntype\n filters by class. Note that this method does not take a \nfailed\n argument and it returns all received infos (whether failed or not) whose associcated transmissions are not failed.\n\n\nnode.\nreplicate\n(\ninfo_in\n) \n\nReplicate the \ninfo_in\n - create a new info of the same type with the same contents and then create a Replication (a subclass of Transformation) linking the two.\n\n\nnode\n.transformations\n([\ntype\n, \nfailed\n]) \n\nReturn a list of transformations created by the node. If specified, \ntype\n filters by class. By default failed transformations are excluded, to include only failed transformations use \nfailed=True\n, for all transformations use \nfailed=\"all\"\n.\n\n\nnode\n.transmissions\n([\ndirection\n, \nstatus, failed\n]) \n\nReturn a list of transmissions sent/received by the node. \nDirection\n can be \"outgoing\", \"incoming\" or \"all (default is \"outgoing\"). \nStatus\n can be \"pending\", \"received\", or \"all\" (default is \"all\"). By default failed transmissions are excluded, to include only failed transmissions use \nfailed=True\n, for all transmissions use \nfailed=\"all\"\n.\n\n\nnode.\ntransmit\n([\nwhat\n, \nto_whom\n]) \n\nReturn a (list of) newly created transmission(s) of \nwhat\n to \nto_whom\n. \nWhat\n specifies what to send, it can be an info created by the node, a list of infos created by the node, a class of info (in which case all infos of that class created by the node are sent), None (in which case the node._what() is called to determine what to send), or a (nested) list of any of the above. \nTo_whom\n specifies which node(s) the transmission(s) should be sent to, it can be a Node, a list of Nodes, a class of Node (in which case all neighbors of that type will be sent to), None (in which case node.to_whom() is called to determine who to send to) or a (nested) list of any of the above. Nodes can only transmit infos they have made and can only transmit to nodes they are connected to.\n\n\nnode.\nupdate\n(\ninfos\n) \n\nProcess received infos, called by node.receive(). By default this method does nothing. It is intended to be overwritten to provide subclasses of node new behaviors that occur automatically when they receive transmissions.\n\n\nnode\n.vectors\n([\ndirection\n, \nfailed\n]) \n\nReturn a list of vectors connected to the node. Direction specfies whether to include vectors that originate from or arrive at the node. It defaults to \"all\", but can also be \"incoming\" or \"outgoing\". By default failed vectors are excluded, to include only failed vectors use \nfailed=True\n, for all vectors use \nfailed=\"all\"\n.\n\n\nVector\n\n\nA vector is a directional link between two nodes. Nodes connected by a vector can send Transmissions to each other, but because Vectors have a direction, two Vectors are needed for bi-directional Transmissions.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Vector was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Vector has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"vector\". This allows subclassing.\n\n\norigin_id\n - the id of the Node at which the vector originates.\n\n\ndestination_id\n - the id of the Node at which the vector terminates.\n\n\nnetwork_id\n - the id of the network the vector is in.\n\n\n\n\nRelationships\n\n\n\n\norigin\n - the Node at which the vector originates.\n\n\ndestination\n - the Node at which the vector terminates.\n\n\nnetwork\n - the network the vector is in.\n\n\nall_transmissions\n - all Transmissions sent along the Vector.\n\n\n\n\nMethods\n\n\nvector.\n__repr__()\n \n\nReturn a simple string representation of the vector.\n\n\nvector\n.__json__()\n \n\nReturn a json object with all the attributes of the vector.\n\n\nvector\n.fail()\n \n\nSet vector.failed to True and vector.time_of_death to now. Instruct all transmissions sent along this vector to fail.\n\n\nvector\n.transmissions\n([\nstatus\n]) \n\nReturn a list of transmissions sent along the vector. \nStatus\n can be \"pending\", \"received\", or \"all\" (default is \"all\").\n\n\nInfo\n\n\nAn Info is a piece of information created by a Node. It can be sent along Vectors as part of a Transmission.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Info was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Info has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"info\". This allows subclassing.\n\n\norigin_id\n - the id of the Node that created the info.\n\n\nnetwork_id\n - the id of the network the info is in.\n\n\ncontents\n - the contents of the info. Must be stored as a String.\n\n\n\n\nRelationships\n\n\n\n\norigin\n - the Node that created the info.\n\n\nnetwork\n - the network the info is in.\n\n\nall_transmissions\n - all Transmissions of this Info.\n\n\ntransformation_applied_to\n - all Transformations of which this info is the info_in\n\n\ntransformation_whence\n - all Transformations of which this info is the info_out\n\n\n\n\nMethods\n\n\ninfo.\n__repr__()\n \n\nReturn a simple string representation of the info.\n\n\ninfo.\n__json__()\n \n\nReturn a json object with all the attributes of the info.\n\n\ninfo.\n_mutated_contents()\n \n\nReturn a string that will be the contents of an info created via a mutation of this info.\n\n\ninfo\n.fail()\n \n\nSet info.failed to True and info.time_of_death to now. Instruct all transmissions and transformations involving this info to fail.\n\n\ninfo\n.transformations\n([\nrelationship\n]) \n\nReturn a list of transformations involving this info. \nRelationship\n can be \"parent\" (in which case only transformations where the info is the \ninfo_in\n are returned), \"child\" (in which case only transformations where the info is the \ninfo_out\n are returned) or \"all\" (in which case any transformations where the info is the \ninfo_out\n or the \ninfo_in\n are returned). The default is \"all\"\n\n\ninfo\n.transmissions\n([\nstatus\n]) \n\nReturn a list of transmissions of this info. \nStatus\n can be \"pending\", \"received\", or \"all\" (default is \"all\").\n\n\nTransmission\n\n\nA transmission represents an instance of an Info being sent along a Vector. Transmissions are not necessarily received when they are sent (like an email) and must also be received by the Node they are sent to.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Transmission was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Transmission has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"transmission\". This allows subclassing.\n\n\norigin_id\n - the id of the Node that sent the transmission.\n\n\ndestination_id\n - the id of the Node that the transmission was sent to.\n\n\nvector_id\n - the id of the vector the info was sent along.\n\n\nnetwork_id\n - the id of the network the transmission is in.\n\n\ninfo_id\n - the id of the info that was transmitted.\n\n\nreceive_time\n - the time at which the transmission was received.\n\n\nstatus\n - the status of the transmission, can be:\n\n\npending\n - transmission has been sent, but not received.\n\n\nreceived\n - transmissions has been sent and received.\n\n\n\n\n\n\n\n\nRelationships\n\n\n\n\norigin\n - the Node that sent the transmission.\n\n\ndestination\n - the Node that the transmission was sent to.\n\n\nvector\n - the vector the info was sent along.\n\n\nnetwork\n - the network the transmission is in.\n\n\ninfo\n - the info that was transmitted.\n\n\n\n\nMethods\n\n\ntransmission.\n__repr__()\n \n\nReturn a simple string representation of the transmission.\n\n\ntransmission.\n__json__()\n \n\nReturn a json object with all the attributes of the transmission.\n\n\ntransmission.\nfail()\n \n\nSet transmission.failed to True and transmission.time_of_death to now.\n\n\ntransmission.\nmark_received()\n \n\nSet transmission.status to \"received\" and transmission.receive_time to now.\n\n\nTransformation\n\n\nA Transformation is a relationship between two Infos. It is similar to how a Vector indicates a relationship between two Nodes, but whereas a Vector allows Nodes to Transmit to each other, Transformations don't allow Infos to do anything new. Instead they are a form of book-keeping allowing you to keep track of relationships between various Infos.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Transformation was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Transformation has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"transformation\". This allows subclassing.\n\n\nnode_id\n - the id of the Node that did the transformation.\n\n\nnetwork_id\n - the id of the network the transmission is in.\n\n\ninfo_in_id\n - the id of the info that was transformed.\n\n\ninfo_out_id\n - the id of the info produced by the transformation.\n\n\n\n\nRelationships\n\n\n\n\nnode\n - the Node that did the transformation.\n\n\nnetwork\n - the network the transmission is in.\n\n\ninfo_in\n - the info that was transformed.\n\n\ninfo_out\n - the info produced by the transformation.\n\n\n\n\ntransformation.\n__repr__()\n \n\nReturn a simple string representation of the transformation.\n\n\ntransformation.\n__json__()\n \n\nReturn a json object with all the attributes of the transformation.\n\n\ntransformation.\nfail()\n \n\nSet transformation.failed to True and transformation.time_of_death to now.\n\n\nParticipant\n\n\nThe Participant object corresponds to a real world participant. Each person who takes part will have a corresponding entry in the Participant table. Participants can be associated with Nodes and Questions.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Participant was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Participant has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"participant\". This allows subclassing.\n\n\nworker_id\n - A String, the worker id of the participant.\n\n\nassignment_id\n - A String, the assignment id of the participant.\n\n\nunique_id\n - A String, a concatenation of the worker_id and assignment_id, used by psiTurk.\n\n\nhit_id\n - A String, the id of the hit the participant is working on.\n\n\nmode\n - A String, the mode in which Wallace is running: live, sandbox or debug.\n\n\nend_time\n - The time at which the participant finished.\n\n\nbase_pay\n - The amount the participant was paid for finishing the experiment.\n\n\nbonus\n - the amount the participant was paid as a bonus.\n\n\nstatus\n - String representing the current status of the participant, can be:\n\n\nworking\n - participant is working\n\n\nsubmitted\n - participant has submitted their work\n\n\napproved\n - their work has been approved and they have been paid\n\n\nrejected\n - their work has been rejected\n\n\nreturned\n - they returned the hit before finishing\n\n\nabandoned\n - they ran out of time\n\n\ndid_not_attend\n - the participant finished, but failed the attention check\n\n\nbad_data\n - the participant finished, but their data was malformed\n\n\nmissing notification\n - this indicates that Wallace has inferred that an MTurk notification corresponding to this participant failed to arrive. This is an uncommon, but potentially serious issue.\n\n\n\n\n\n\n\n\nRelationships\n\n\n\n\nall_questions\n - all the questions associated with this participant.\n\n\nall_nodes\n - all the Nodes associated with this participant.\n\n\n\n\nMethods\n\n\nparticipant\n.__json__()\n \n\nReturn a json object with all the attributes of the participant.\n\n\nparticipant\n.fail()\n \n\nSet participant.failed to True and participant.time_of_death to now. Instruct all not-failed nodes associated with the participant to fail.\n\n\nparticipant.\ninfos\n([\ntype\n, \nfailed\n]) \n\nReturn a list of infos produced by nodes associated with the participant. If specified, \ntype\n filters by class. By default, failed infos are excluded, to include only failed nodes use \nfailed=True\n, for all nodes use \nfailed=\"all\"\n. Note that failed filters the infos, not the nodes - infos from all nodes (whether failed or not) can be returned.\n\n\nparticipant.\nnodes\n([\ntype\n, \nfailed\n]) \n\nReturn a list of nodes associated with the participant. If specified, \ntype\n filters by class. By default failed nodes are excluded, to include only failed nodes use \nfailed=True\n, for all nodes use \nfailed=\"all\"\n.\n\n\nparticipant.\nquestions\n([\ntype\n]) \n\nReturn a list of questions associated with the participant. If specified, \ntype\n filters by class.\n\n\nQuestion\n\n\nA Question is a way to store information associated with a Participant as opposed to a Node (Infos are made by Nodes, not Participants). Questions are generally useful for storing responses debriefing questions etc.\n\n\nColumns\n\n\n\n\nid\n - a unique number for every entry. 1, 2, 3 and so on...\n\n\ncreation_time\n - the time at which the Question was created.\n\n\nproperty1\n - a generic column that can be used to store experiment specific details in String form.\n\n\nproperty2\n, \n3\n, \n4\n and \n5\n - same as above.\n\n\nfailed\n - boolean indicating whether the Question has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.\n\n\ntime_of_death\n - the time at which failing occurred.\n\n\ntype\n - a String giving the name of the class. Defaults to \"question\". This allows subclassing.\n\n\nquestion_id\n - a number. E.g., each participant might complete three questions numbered 1, 2, and 3.\n\n\nquestion\n - the text of the question.\n\n\nresponse\n - the participant's response. Stored as a string.\n\n\n\n\nRelationships\n\n\n\n\nparticipant\n - the participant who answered the question.\n\n\n\n\nMethods\n\n\nquestion\n.fail()\n \n\nSet question.failed to True and question.time_of_death to now.", 
            "title": "Classes"
        }, 
        {
            "location": "/Classes/#network", 
            "text": "The  Network  object can be imagined as a set of other objects with some functions that perform operations over those objects. The objects that  Network s have direct access to are all the  Node s in the network, the  Vector s between those Nodes, Infos created by those Nodes, Transmissions sent along the Vectors by those Nodes and Transformations of those Infos. Participants and Questions do not exist within Networks. An experiment may involve multiple Networks, Transmissions can only occur within networks, not between them.", 
            "title": "Network"
        }, 
        {
            "location": "/Classes/#columns", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Network was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Network has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"network\". This allows subclassing.  max_size  - the maximum number of Nodes the Network can contain.  full  - a boolean indicating whether the network has reached its max_size.  role  - a String identifying the purpose of the Network. Any value can be used, but by default Wallace treats Networks with a role of \"practice\" differently.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships", 
            "text": "all_nodes  - all the Nodes in the network.   all_vectors  - all the Vectors in the network.  all_infos  - all the Infos in the network.  networks_transmissions  - all the Transmissions in the network.  networks_transformations  - all the Transformations in the network.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#functions", 
            "text": "Network.__repr__()   \nReturn a simple string representation of the network.  Network.__json__()   \nReturn a json object with all the attributes of the network.  Network.calculate_full()   \nUpdate attribute network.full to reflect current network size.  Network.fail()   \nSet  network.failed  to True and  network.time_of_death  to  now . Instruct all not-failed nodes in the network to fail.  Network.infos([type, failed])   \nReturn a list of infos in the network (i.e., infos made by nodes in the network). If specified,  type  filters by class. By default failed infos are excluded, to include only failed infos use  failed=True , for all infos use  failed=\"all\" .  network .latest_transmission_recipient()   \nReturn the node that most recently received a transmission.  network .nodes ([ type, failed, participant_id ])  \nReturn a list of nodes in the network. If specified,  type  filters by class and  participant_id  filters by the nodes' associated participants. By default failed nodes are excluded, to include only failed nodes use  failed=True , for all nodes use  failed=\"all\" .  network .print_verbose()   \nPrint a verbose description of the network.  network .size ([ type, failed ])  \nReturn the number of nodes in the network. If specified,  type  filters by class. By default failed nodes are excluded, to include only failed nodes use  failed=True , for all nodes use  failed=\"all\" .  network .transformations ([ type, failed ])  \nReturn a list of transformations in the network (i.e., transformations by nodes in the network). If specified,  type  filters by class. By default failed transformations are excluded, to include only failed transformations use  failed=True , for all transformations use  failed=\"all\" .  network .transmissions ([ status, failed ])  \nReturn a list of transmissions in the network.  status  can be \"pending\" or \"received\" (default is \"all\"). By default failed transmissions are excluded, to include only failed transmissions use  failed=True , for all transmissions use  failed=\"all\" .  network .vectors ([ failed ])  \nReturn a list of vectors in the network. By default failed vectors are excluded, to include only failed vectors use  failed=True , for all vectors use  failed=\"all\" .", 
            "title": "Functions"
        }, 
        {
            "location": "/Classes/#node", 
            "text": "Each Node represents a single point in a single network. A Node must be within a Network and may also be associated with a Participant.", 
            "title": "Node"
        }, 
        {
            "location": "/Classes/#columns_1", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Node was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Node has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"node\". This allows subclassing.  network_id  - the id of the network the node is in.  participant_id  - the id of the participant the node is associated with.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_1", 
            "text": "network  - the network the node is in.  participant  - the participant the node is associated with.  all_outgoing_vectors  - all the vectors going out from this Node.  all_incoming_vectors  - all the vectors coming in to this Node.  all_infos  - all Infos created by this Node.  all_outgoing_transmissions  - all Transmissions sent from this Node.  all_incoming_transmissions  - all Transmissions sent to this Node.  transformations_here  - all transformations that took place at this Node.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#methods", 
            "text": "node. __repr__()   \nReturn a simple string representation of the node.  node .__json__()   \nReturn a json object with all the attributes of the node.  node. _to_whom()   \nReturn the default value of  to_whom  for node.transmit(). Should not return None or a list containing None.  node. _what()   \nReturn the default value of  what  for node.transmit(). Should not return None or a list containing None.  node. connect ( whom , [ direction ])  \nReturn a list of newly created vector between the node and whom.  Whom  can be a specific node or a (nested) list of nodes. Nodes can only connect with nodes in the same network. In addition nodes cannot connect with themselves or with Sources.  Direction  specifies the direction of the connection it can be \"to\" (node -  whom), \"from\" (whom -  node) or both (node  -  whom). The defult is \"to\".  node .fail()   \nSet node.failed to True and node.time_of_death to now. Instruct all not-failed vectors connected to this node, infos made by this node, transmissions to or from this node and transformations made by this node to fail.  node. is_connected ( whom , [ direction ])  \nReturn a (list of) boolean(s) indicating whether the node has a connection to  whom .  Whom  can be a single other node or a list of other nodes, if the former return a boolean, if the latter return a list of booleans.  Direction  specifies whether the required direction of the connection. The default value is \"to\", other values are \"from\", \"both\" and \"either\". Note that this method does not take a  failed  argument and it will only look along not failed vectors.  node .infos ([ type, failed ])  \nReturn a list of infos created by the node. If specified,  type  filters by class. By default failed infos are excluded, to include only failed infos use  failed=True , for all infos use  failed=\"all\" .  node. mutate ( info_in )  \nMutate the  info_in  - create a new info of the same type with its contents determined by info_in.mutated_contents() and then create a Mutation (a subclass of Transformation) linking the two.  node. neighbors ([ type ,  direction ])  \nReturn a list of other nodes with an immediate connection to this node. If specified,  type  filters neighboring nodes by class.  Direction  specifies the direction of the connection and can be \"to\", \"from\", \"both\" or \"either\"; the default value is \"to\". Note that a  failed  argument should not be passed to node.neighbors() and the function only returns not failed nodes connected by not failed vectors.  node. receive ([ what ])  \nReceive incoming transmissions.  What  specifies what to receive. It can be a specific transmission. If  what  is not specified all pending transmissions are received. Received transmissions have their status set to \"received\" and their receive_time set to now. A list of all the infos associated with the received transmissions is passed to node.update().  node .received_infos ([ type ])  \nReturn a list of infos received by the node (i.e., transmitted to the node and received). If specified,  type  filters by class. Note that this method does not take a  failed  argument and it returns all received infos (whether failed or not) whose associcated transmissions are not failed.  node. replicate ( info_in )  \nReplicate the  info_in  - create a new info of the same type with the same contents and then create a Replication (a subclass of Transformation) linking the two.  node .transformations ([ type ,  failed ])  \nReturn a list of transformations created by the node. If specified,  type  filters by class. By default failed transformations are excluded, to include only failed transformations use  failed=True , for all transformations use  failed=\"all\" .  node .transmissions ([ direction ,  status, failed ])  \nReturn a list of transmissions sent/received by the node.  Direction  can be \"outgoing\", \"incoming\" or \"all (default is \"outgoing\").  Status  can be \"pending\", \"received\", or \"all\" (default is \"all\"). By default failed transmissions are excluded, to include only failed transmissions use  failed=True , for all transmissions use  failed=\"all\" .  node. transmit ([ what ,  to_whom ])  \nReturn a (list of) newly created transmission(s) of  what  to  to_whom .  What  specifies what to send, it can be an info created by the node, a list of infos created by the node, a class of info (in which case all infos of that class created by the node are sent), None (in which case the node._what() is called to determine what to send), or a (nested) list of any of the above.  To_whom  specifies which node(s) the transmission(s) should be sent to, it can be a Node, a list of Nodes, a class of Node (in which case all neighbors of that type will be sent to), None (in which case node.to_whom() is called to determine who to send to) or a (nested) list of any of the above. Nodes can only transmit infos they have made and can only transmit to nodes they are connected to.  node. update ( infos )  \nProcess received infos, called by node.receive(). By default this method does nothing. It is intended to be overwritten to provide subclasses of node new behaviors that occur automatically when they receive transmissions.  node .vectors ([ direction ,  failed ])  \nReturn a list of vectors connected to the node. Direction specfies whether to include vectors that originate from or arrive at the node. It defaults to \"all\", but can also be \"incoming\" or \"outgoing\". By default failed vectors are excluded, to include only failed vectors use  failed=True , for all vectors use  failed=\"all\" .", 
            "title": "Methods"
        }, 
        {
            "location": "/Classes/#vector", 
            "text": "A vector is a directional link between two nodes. Nodes connected by a vector can send Transmissions to each other, but because Vectors have a direction, two Vectors are needed for bi-directional Transmissions.", 
            "title": "Vector"
        }, 
        {
            "location": "/Classes/#columns_2", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Vector was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Vector has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"vector\". This allows subclassing.  origin_id  - the id of the Node at which the vector originates.  destination_id  - the id of the Node at which the vector terminates.  network_id  - the id of the network the vector is in.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_2", 
            "text": "origin  - the Node at which the vector originates.  destination  - the Node at which the vector terminates.  network  - the network the vector is in.  all_transmissions  - all Transmissions sent along the Vector.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#methods_1", 
            "text": "vector. __repr__()   \nReturn a simple string representation of the vector.  vector .__json__()   \nReturn a json object with all the attributes of the vector.  vector .fail()   \nSet vector.failed to True and vector.time_of_death to now. Instruct all transmissions sent along this vector to fail.  vector .transmissions ([ status ])  \nReturn a list of transmissions sent along the vector.  Status  can be \"pending\", \"received\", or \"all\" (default is \"all\").", 
            "title": "Methods"
        }, 
        {
            "location": "/Classes/#info", 
            "text": "An Info is a piece of information created by a Node. It can be sent along Vectors as part of a Transmission.", 
            "title": "Info"
        }, 
        {
            "location": "/Classes/#columns_3", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Info was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Info has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"info\". This allows subclassing.  origin_id  - the id of the Node that created the info.  network_id  - the id of the network the info is in.  contents  - the contents of the info. Must be stored as a String.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_3", 
            "text": "origin  - the Node that created the info.  network  - the network the info is in.  all_transmissions  - all Transmissions of this Info.  transformation_applied_to  - all Transformations of which this info is the info_in  transformation_whence  - all Transformations of which this info is the info_out", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#methods_2", 
            "text": "info. __repr__()   \nReturn a simple string representation of the info.  info. __json__()   \nReturn a json object with all the attributes of the info.  info. _mutated_contents()   \nReturn a string that will be the contents of an info created via a mutation of this info.  info .fail()   \nSet info.failed to True and info.time_of_death to now. Instruct all transmissions and transformations involving this info to fail.  info .transformations ([ relationship ])  \nReturn a list of transformations involving this info.  Relationship  can be \"parent\" (in which case only transformations where the info is the  info_in  are returned), \"child\" (in which case only transformations where the info is the  info_out  are returned) or \"all\" (in which case any transformations where the info is the  info_out  or the  info_in  are returned). The default is \"all\"  info .transmissions ([ status ])  \nReturn a list of transmissions of this info.  Status  can be \"pending\", \"received\", or \"all\" (default is \"all\").", 
            "title": "Methods"
        }, 
        {
            "location": "/Classes/#transmission", 
            "text": "A transmission represents an instance of an Info being sent along a Vector. Transmissions are not necessarily received when they are sent (like an email) and must also be received by the Node they are sent to.", 
            "title": "Transmission"
        }, 
        {
            "location": "/Classes/#columns_4", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Transmission was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Transmission has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"transmission\". This allows subclassing.  origin_id  - the id of the Node that sent the transmission.  destination_id  - the id of the Node that the transmission was sent to.  vector_id  - the id of the vector the info was sent along.  network_id  - the id of the network the transmission is in.  info_id  - the id of the info that was transmitted.  receive_time  - the time at which the transmission was received.  status  - the status of the transmission, can be:  pending  - transmission has been sent, but not received.  received  - transmissions has been sent and received.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_4", 
            "text": "origin  - the Node that sent the transmission.  destination  - the Node that the transmission was sent to.  vector  - the vector the info was sent along.  network  - the network the transmission is in.  info  - the info that was transmitted.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#methods_3", 
            "text": "transmission. __repr__()   \nReturn a simple string representation of the transmission.  transmission. __json__()   \nReturn a json object with all the attributes of the transmission.  transmission. fail()   \nSet transmission.failed to True and transmission.time_of_death to now.  transmission. mark_received()   \nSet transmission.status to \"received\" and transmission.receive_time to now.", 
            "title": "Methods"
        }, 
        {
            "location": "/Classes/#transformation", 
            "text": "A Transformation is a relationship between two Infos. It is similar to how a Vector indicates a relationship between two Nodes, but whereas a Vector allows Nodes to Transmit to each other, Transformations don't allow Infos to do anything new. Instead they are a form of book-keeping allowing you to keep track of relationships between various Infos.", 
            "title": "Transformation"
        }, 
        {
            "location": "/Classes/#columns_5", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Transformation was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Transformation has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"transformation\". This allows subclassing.  node_id  - the id of the Node that did the transformation.  network_id  - the id of the network the transmission is in.  info_in_id  - the id of the info that was transformed.  info_out_id  - the id of the info produced by the transformation.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_5", 
            "text": "node  - the Node that did the transformation.  network  - the network the transmission is in.  info_in  - the info that was transformed.  info_out  - the info produced by the transformation.   transformation. __repr__()   \nReturn a simple string representation of the transformation.  transformation. __json__()   \nReturn a json object with all the attributes of the transformation.  transformation. fail()   \nSet transformation.failed to True and transformation.time_of_death to now.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#participant", 
            "text": "The Participant object corresponds to a real world participant. Each person who takes part will have a corresponding entry in the Participant table. Participants can be associated with Nodes and Questions.", 
            "title": "Participant"
        }, 
        {
            "location": "/Classes/#columns_6", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Participant was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Participant has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"participant\". This allows subclassing.  worker_id  - A String, the worker id of the participant.  assignment_id  - A String, the assignment id of the participant.  unique_id  - A String, a concatenation of the worker_id and assignment_id, used by psiTurk.  hit_id  - A String, the id of the hit the participant is working on.  mode  - A String, the mode in which Wallace is running: live, sandbox or debug.  end_time  - The time at which the participant finished.  base_pay  - The amount the participant was paid for finishing the experiment.  bonus  - the amount the participant was paid as a bonus.  status  - String representing the current status of the participant, can be:  working  - participant is working  submitted  - participant has submitted their work  approved  - their work has been approved and they have been paid  rejected  - their work has been rejected  returned  - they returned the hit before finishing  abandoned  - they ran out of time  did_not_attend  - the participant finished, but failed the attention check  bad_data  - the participant finished, but their data was malformed  missing notification  - this indicates that Wallace has inferred that an MTurk notification corresponding to this participant failed to arrive. This is an uncommon, but potentially serious issue.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_6", 
            "text": "all_questions  - all the questions associated with this participant.  all_nodes  - all the Nodes associated with this participant.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#methods_4", 
            "text": "participant .__json__()   \nReturn a json object with all the attributes of the participant.  participant .fail()   \nSet participant.failed to True and participant.time_of_death to now. Instruct all not-failed nodes associated with the participant to fail.  participant. infos ([ type ,  failed ])  \nReturn a list of infos produced by nodes associated with the participant. If specified,  type  filters by class. By default, failed infos are excluded, to include only failed nodes use  failed=True , for all nodes use  failed=\"all\" . Note that failed filters the infos, not the nodes - infos from all nodes (whether failed or not) can be returned.  participant. nodes ([ type ,  failed ])  \nReturn a list of nodes associated with the participant. If specified,  type  filters by class. By default failed nodes are excluded, to include only failed nodes use  failed=True , for all nodes use  failed=\"all\" .  participant. questions ([ type ])  \nReturn a list of questions associated with the participant. If specified,  type  filters by class.", 
            "title": "Methods"
        }, 
        {
            "location": "/Classes/#question", 
            "text": "A Question is a way to store information associated with a Participant as opposed to a Node (Infos are made by Nodes, not Participants). Questions are generally useful for storing responses debriefing questions etc.", 
            "title": "Question"
        }, 
        {
            "location": "/Classes/#columns_7", 
            "text": "id  - a unique number for every entry. 1, 2, 3 and so on...  creation_time  - the time at which the Question was created.  property1  - a generic column that can be used to store experiment specific details in String form.  property2 ,  3 ,  4  and  5  - same as above.  failed  - boolean indicating whether the Question has failed which prompts Wallace to ignore it unless specified otherwise. Objects are usually failed to indicate something has gone wrong.  time_of_death  - the time at which failing occurred.  type  - a String giving the name of the class. Defaults to \"question\". This allows subclassing.  question_id  - a number. E.g., each participant might complete three questions numbered 1, 2, and 3.  question  - the text of the question.  response  - the participant's response. Stored as a string.", 
            "title": "Columns"
        }, 
        {
            "location": "/Classes/#relationships_7", 
            "text": "participant  - the participant who answered the question.", 
            "title": "Relationships"
        }, 
        {
            "location": "/Classes/#methods_5", 
            "text": "question .fail()   \nSet question.failed to True and question.time_of_death to now.", 
            "title": "Methods"
        }, 
        {
            "location": "/Web-API/", 
            "text": "The Wallace API allows the experiment frontend to communicate with the backend. Many of these routes correspond to specific functions of Wallace's \nclasses\n, particularly \nNode\n. For example, nodes have a \nconnect\n method that creates new vectors between nodes and there is a corresponding \nconnect/\n route that allows the frontend to call this method.\n\n\nMiscellaneous routes\n\n\n/ad_address/\nmode\n/\nhit_id\n [GET] \n\nUsed to get the address of the experiment on the psiTurk server and to return participants to MTurk upon completion of the experiment. This route is pinged automatically by the function \nsubmit_assignment\n in wallace.js.\n\n\n/\ndirectory\n/\npage\n [GET] \n\nReturns the html page with the name \npage\n from the directory called \ndirectory\n.\n\n\n/summary\n [GET] \n\nReturns a summary of the statuses of Participants.\n\n\n/\npage\n [GET] \n\nReturns the html page with the name \npage\n.\n\n\nExperiment routes\n\n\n/experiment_property/\nproperty\n [GET] \n\nReturns the value of the requested property as a JSON \nproperty\n.\n\n\n/info/\nnode_id\n/\ninfo_id\n [GET] \n\nReturns a JSON description of the requested info as \ninfo\n. \nnode_id\n must be specified to ensure the requesting node has access to the requested info. Calls experiment method `info_get_request(node, info).\n\n\n/info/\nnode_id\n [POST] \n\nCreate an info with its origin set to the specified node. \ncontents\n must be passed as data. \ninfo_type\n can be passed as data and will cause the info to be of the specified type. Also calls experiment method \ninfo_post_request(node, info)\n.\n\n\n/launch\n [POST] \n\nInitializes the experiment and opens recruitment. This route is automatically pinged by Wallace.\n\n\n/network/\nnetwork_id\n [GET] \n\nReturns a JSON description of the requested network as \nnetwork\n.\n\n\n/node/\nnode_id\n/connect/\nother_node_id\n [POST] \n\nCreate vector(s) between the \nnode\n and \nother_node\n by calling \nnode.connect(whom=other_node)\n. Direction can be passed as data and will be forwarded as an argument. Calls experiment method \nvector_post_request(node, vectors)\n. Returns a list of JSON descriptions of the created vectors as \nvectors\n.\n\n\n/node/\nnode_id\n/infos\n [GET] \n\nReturns a list of JSON descriptions of the infos created by the node as \ninfos\n. Infos are identified by calling \nnode.infos()\n. \ninfo_type\n can be passed as data and will be forwarded as an argument. Requesting node and the list of infos are also passed to experiment method \ninfo_get_request(node, infos)\n.\n\n\n/node/\nnode_id\n/neighbors\n [GET] \n\nReturns a list of JSON descriptions of the node's neighbors as \nnodes\n. Neighbors are identified by calling \nnode.neighbors()\n. \nnode_type\n and \nconnection\n can be passed as data and will be forwarded as arguments. Requesting node and list of neighbors are also passed to experiment method \nnode_get_request(node, nodes)\n.\n\n\n/node/\nnode_id\n/received_infos\n [GET] \n\nReturns a list of JSON descriptions of the infos sent to the node as \ninfos\n. Infos are identified by calling \nnode.received_infos()\n. \ninfo_type\n can be passed as data and will be forwarded as an argument. Requesting node and the list of infos are also passed to experiment method \ninfo_get_request(node, infos)\n.\n\n\n/node/\nint:node_id\n/transformations\n [GET] \n\nReturns a list of JSON descriptions of all the transformations of a node identified using \nnode.transformations()\n. The node id must be specified in the url. You can also pass \ntransformation_type\n as data and it will be forwarded to \nnode.transformations()\n as the argument \ntype\n.\n\n\n/node/\nnode_id\n/transmissions\n [GET] \n\nReturns a list of JSON descriptions of the transmissions sent to/from the node as \ntransmissions\n. Transmissions are identified by calling \nnode.transmissions()\n. \ndirection\n and \nstatus\n can be passed as data and will be forwarded as arguments. Requesting node and the list of transmissions are also passed to experiment method \ntransmission_get_request(node, transmissions)\n.\n\n\n/node/\nnode_id\n/transmit\n [POST] \n\nTransmit to another node by calling \nnode.transmit()\n. The sender's node id must be specified in the url. As with \nnode.transmit()\n the key parameters are \nwhat\n and \nto_whom\n and they should be passed as data. However, the values these accept are more limited than for the backend due to the necessity of serialization. \n\nIf \nwhat\n and \nto_whom\n are not specified they will default to \nNone\n.\nAlternatively you can pass an int (e.g. '5') or a class name (e.g.\n\nInfo\n or \nAgent\n). Passing an int will get that info/node, passing\na class name will pass the class. Note that if the class you are specifying\nis a custom class it will need to be added to the dictionary of\nknown_classes in your experiment code. \n\nYou may also pass the values property1, property2, property3, property4\nand property5. If passed this will fill in the relevant values of the\ntransmissions created with the values you specified. \n\nThe transmitting node and a list of created transmissions are sent to experiment method \ntransmission_post_request(node, transmissions)\n. This route returns a list of JSON descriptions of the created transmissions as \ntransmissions\n.\nFor example, to transmit all infos of type Meme to the node with id 10:\n\n\nreqwest({\n    url: \n/node/\n + my_node_id + \n/transmit\n,\n    method: 'post',\n    type: 'json',\n    data: {\n        what: \nMeme\n,\n        to_whom: 10,\n    },\n});\n\n\n\n\n/node/\nnode_id\n/vectors\n [GET] \n\nReturns a list of JSON descriptions of vectors connected to the node as \nvectors\n. Vectors are identified by calling \nnode.vectors()\n. \ndirection\n and \nfailed\n can be passed as data and will be forwarded as arguments. Requesting node and list of vectors are also passed to experiment method \nvector_get_request(node, vectors)\n. \n\n\n/node/\nparticipant_id\n [POST] \n\nCreate a node for the specified participant. The route calls the following experiment methods: \nget_network_for_participant(participant)\n, \ncreate_node(network, participant)\n, \nadd_node_to_network(node, network)\n, and \nnode_post_request(participant, node)\n. Returns a JSON description of the created node as \nnode\n.\n\n\n/notifications\n [POST, GET] \n\nThis is the route to which notifications from AWS are sent. It is also possible to send your own notifications to this route, thereby simulating notifications from AWS. Necessary arguments are \nEvent.1.EventType\n, which can be \nAssignmentAccepted\n, \nAssignmentAbandoned\n, \nAssignmentReturned\n or \nAssignmentSubmitted\n, and \nEvent.1.AssignmentId\n, which is the id of the relevant assignment. In addition, Wallace uses a custom event type of \nNotificationMissing\n.\n\n\n/participant/\nparticipant_id\n [GET] \n\nReturns a JSON description of the requested participant as \nparticipant\n.\n\n\n/participant/\nworker_id\n/\nhit_id\n/\nassignment_id\n/\nmode\n [POST] \n\nCreate a participant. Returns a JSON description of the participant as \nparticipant\n.\n\n\n/question/\nparticipant_id\n [POST] \n\nCreate a question. \nquestion\n, \nresponse\n and \nquestion_id\n should be passed as data. Does not return anything.\n\n\n/transformation/\nint:node_id\n/\nint:info_in_id\n/\nint:info_out_id\n [POST] \nCreate a transformation from \ninfo_in\n to \ninfo_out\n at the specified node. \ntransformation_type\n can be passed as data and the transformation will be of that class if it is a known class. Returns a JSON description of the created transformation.", 
            "title": "Web API"
        }, 
        {
            "location": "/Web-API/#miscellaneous-routes", 
            "text": "/ad_address/ mode / hit_id  [GET]  \nUsed to get the address of the experiment on the psiTurk server and to return participants to MTurk upon completion of the experiment. This route is pinged automatically by the function  submit_assignment  in wallace.js.  / directory / page  [GET]  \nReturns the html page with the name  page  from the directory called  directory .  /summary  [GET]  \nReturns a summary of the statuses of Participants.  / page  [GET]  \nReturns the html page with the name  page .", 
            "title": "Miscellaneous routes"
        }, 
        {
            "location": "/Web-API/#experiment-routes", 
            "text": "/experiment_property/ property  [GET]  \nReturns the value of the requested property as a JSON  property .  /info/ node_id / info_id  [GET]  \nReturns a JSON description of the requested info as  info .  node_id  must be specified to ensure the requesting node has access to the requested info. Calls experiment method `info_get_request(node, info).  /info/ node_id  [POST]  \nCreate an info with its origin set to the specified node.  contents  must be passed as data.  info_type  can be passed as data and will cause the info to be of the specified type. Also calls experiment method  info_post_request(node, info) .  /launch  [POST]  \nInitializes the experiment and opens recruitment. This route is automatically pinged by Wallace.  /network/ network_id  [GET]  \nReturns a JSON description of the requested network as  network .  /node/ node_id /connect/ other_node_id  [POST]  \nCreate vector(s) between the  node  and  other_node  by calling  node.connect(whom=other_node) . Direction can be passed as data and will be forwarded as an argument. Calls experiment method  vector_post_request(node, vectors) . Returns a list of JSON descriptions of the created vectors as  vectors .  /node/ node_id /infos  [GET]  \nReturns a list of JSON descriptions of the infos created by the node as  infos . Infos are identified by calling  node.infos() .  info_type  can be passed as data and will be forwarded as an argument. Requesting node and the list of infos are also passed to experiment method  info_get_request(node, infos) .  /node/ node_id /neighbors  [GET]  \nReturns a list of JSON descriptions of the node's neighbors as  nodes . Neighbors are identified by calling  node.neighbors() .  node_type  and  connection  can be passed as data and will be forwarded as arguments. Requesting node and list of neighbors are also passed to experiment method  node_get_request(node, nodes) .  /node/ node_id /received_infos  [GET]  \nReturns a list of JSON descriptions of the infos sent to the node as  infos . Infos are identified by calling  node.received_infos() .  info_type  can be passed as data and will be forwarded as an argument. Requesting node and the list of infos are also passed to experiment method  info_get_request(node, infos) .  /node/ int:node_id /transformations  [GET]  \nReturns a list of JSON descriptions of all the transformations of a node identified using  node.transformations() . The node id must be specified in the url. You can also pass  transformation_type  as data and it will be forwarded to  node.transformations()  as the argument  type .  /node/ node_id /transmissions  [GET]  \nReturns a list of JSON descriptions of the transmissions sent to/from the node as  transmissions . Transmissions are identified by calling  node.transmissions() .  direction  and  status  can be passed as data and will be forwarded as arguments. Requesting node and the list of transmissions are also passed to experiment method  transmission_get_request(node, transmissions) .  /node/ node_id /transmit  [POST]  \nTransmit to another node by calling  node.transmit() . The sender's node id must be specified in the url. As with  node.transmit()  the key parameters are  what  and  to_whom  and they should be passed as data. However, the values these accept are more limited than for the backend due to the necessity of serialization.  \nIf  what  and  to_whom  are not specified they will default to  None .\nAlternatively you can pass an int (e.g. '5') or a class name (e.g. Info  or  Agent ). Passing an int will get that info/node, passing\na class name will pass the class. Note that if the class you are specifying\nis a custom class it will need to be added to the dictionary of\nknown_classes in your experiment code.  \nYou may also pass the values property1, property2, property3, property4\nand property5. If passed this will fill in the relevant values of the\ntransmissions created with the values you specified.  \nThe transmitting node and a list of created transmissions are sent to experiment method  transmission_post_request(node, transmissions) . This route returns a list of JSON descriptions of the created transmissions as  transmissions .\nFor example, to transmit all infos of type Meme to the node with id 10:  reqwest({\n    url:  /node/  + my_node_id +  /transmit ,\n    method: 'post',\n    type: 'json',\n    data: {\n        what:  Meme ,\n        to_whom: 10,\n    },\n});  /node/ node_id /vectors  [GET]  \nReturns a list of JSON descriptions of vectors connected to the node as  vectors . Vectors are identified by calling  node.vectors() .  direction  and  failed  can be passed as data and will be forwarded as arguments. Requesting node and list of vectors are also passed to experiment method  vector_get_request(node, vectors) .   /node/ participant_id  [POST]  \nCreate a node for the specified participant. The route calls the following experiment methods:  get_network_for_participant(participant) ,  create_node(network, participant) ,  add_node_to_network(node, network) , and  node_post_request(participant, node) . Returns a JSON description of the created node as  node .  /notifications  [POST, GET]  \nThis is the route to which notifications from AWS are sent. It is also possible to send your own notifications to this route, thereby simulating notifications from AWS. Necessary arguments are  Event.1.EventType , which can be  AssignmentAccepted ,  AssignmentAbandoned ,  AssignmentReturned  or  AssignmentSubmitted , and  Event.1.AssignmentId , which is the id of the relevant assignment. In addition, Wallace uses a custom event type of  NotificationMissing .  /participant/ participant_id  [GET]  \nReturns a JSON description of the requested participant as  participant .  /participant/ worker_id / hit_id / assignment_id / mode  [POST]  \nCreate a participant. Returns a JSON description of the participant as  participant .  /question/ participant_id  [POST]  \nCreate a question.  question ,  response  and  question_id  should be passed as data. Does not return anything.  /transformation/ int:node_id / int:info_in_id / int:info_out_id  [POST] \nCreate a transformation from  info_in  to  info_out  at the specified node.  transformation_type  can be passed as data and the transformation will be of that class if it is a known class. Returns a JSON description of the created transformation.", 
            "title": "Experiment routes"
        }, 
        {
            "location": "/Communicating-with-the-server/", 
            "text": "When an experiment is running, the database and the experiment class (i.e. the instructions for what to do with the database) will be hosted on a server, the server is also known as the \"back-end\". However, participants will take part in experiments via an interactive web-site (the \"front-end\"). Accordingly for an experiment to proceed there must be a means of communication between the front and back ends. This is achieved with routes:\n\n\n\n\nRoutes are specific web addresses on the server that respond to requests from the front-end. Routes have direct access to the database, though most of the time they will pass requests to the experiment which will in turn access the database. As such, changing the behavior of the experiment is the easiest way to create a new experiment. However it is also possible to change the behavior of the routes or add new routes entirely.\n\n\nRequests generally come in two types: \"get\" requests, which ask for information from the database, and \"post\" requests which send new information to be added to the database. Once a request is complete the back-end sends a response back to the front-end. Minimally, this will include a notification that the request was successfully processed, but often it will also include additional information.\n\n\nAs long as requests are properly formatted and correctly addressed to routes, the back-end will send the appropriate response. This means that the front-end could take any form. For instance requests could come from a standard HTML/CSS/JS webpage, a more sophisticated web-app, or even from the experiment itself.", 
            "title": "Communicating with the server"
        }
    ]
}